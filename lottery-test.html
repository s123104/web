<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>雅 (Miyabi) - 3D物理抽選機</title>
    <!-- Fonts & FontAwesome -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&family=Noto+Serif+JP:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">

    <!-- Core Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.0/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon-es/0.20.0/cannon-es.min.js"></script>

    <!-- Helper Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/Draggable.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.4/howler.min.js"></script>
     <!-- Optional: OrbitControls for debugging camera -->
     <!-- <script src="https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js"></script> -->
     <!-- Optional: cannon-es-debugger for visualizing physics -->
     <!-- <script src="https://unpkg.com/cannon-es-debugger@1.0.0/dist/cannon-es-debugger.js"></script> -->


    <style>
        /* --- Base, Title, Control Panel, Winner Display, Particles CSS (Keep similar styles) --- */
        :root { /* Keep color vars */ }
        * { /* Keep resets */ }
        body {
            /* Keep general body styles */
             display: flex;
             flex-direction: column;
             align-items: center;
             justify-content: flex-start; /* Align top */
             min-height: 100vh;
             padding-top: 20px;
        }
        .title-area { /* Keep styles */ }
        .control-panel {
             /* Keep styles, maybe adjust margin */
             margin-top: 20px;
             position: relative; /* Ensure it's not behind canvas */
             z-index: 10;
         }
        .winner-display { /* Keep styles */ z-index: 110; }
        .particles-container { /* Keep styles */ z-index: 100; }
         /* Remove CSS for .lottery-scene, .lottery-machine, .octagon-*, .handle-*, .ball (specific 3D structure ones) */

        /* Style the canvas container */
        #canvas-container {
            width: 100%;
            max-width: 700px; /* Adjust as needed */
            aspect-ratio: 16 / 9; /* Adjust as needed */
            margin: 10px auto;
            position: relative;
            background-color: #eee; /* Placeholder background */
            border-radius: 10px;
            overflow: hidden; /* Clip canvas if needed */
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        canvas {
            display: block; /* Remove extra space below canvas */
            width: 100%;
            height: 100%;
        }

        /* Style the separate handle UI element */
        .handle-ui {
            position: absolute; /* Position relative to canvas or body */
            /* Example positioning - adjust as needed for side view */
            bottom: 15%;
            right: 5%;
            width: 50px;
            height: 150px;
            z-index: 20;
            cursor: grab;
             /* Visual representation - simpler than full 3D CSS handle */
             background: linear-gradient(to right, var(--primary-dark) 0%, #A87038 50%, var(--primary-dark) 100%);
             border-radius: 10px;
             border: 2px solid var(--primary-dark);
             box-shadow: 0 3px 8px rgba(0,0,0,0.3);
             display: flex;
             align-items: flex-start;
             justify-content: center;
             padding-top: 10px;
        }
        .handle-ui-knob {
            width: 40px;
            height: 40px;
            background: var(--gold-gradient);
            border-radius: 50%;
            border: 2px solid #D4AF37;
            box-shadow: 0 0 8px rgba(0,0,0,0.4);
        }
         .handle-ui:active { cursor: grabbing; }

         /* Style for the invisible drag trigger if needed */
         #handleDragTrigger {
             position: absolute;
             /* Position over the visual handle or machine area in canvas */
              bottom: 10%; right: 2%;
              width: 80px; height: 200px; /* Adjust size */
             /* background: rgba(255, 0, 0, 0.2); */ /* Make visible for debugging */
             z-index: 25;
             cursor: grab;
         }
         #handleDragTrigger:active { cursor: grabbing; }

        /* Responsive */
        @media (max-width: 767px) {
            #canvas-container { max-width: 95%; aspect-ratio: 4 / 3; }
            /* Adjust handle UI position/size */
            .handle-ui { width: 40px; height: 120px; bottom: 10%; right: 2%; }
            .handle-ui-knob { width: 30px; height: 30px; }
            #handleDragTrigger { width: 60px; height: 150px; bottom: 5%; right: 0; }
        }

    </style>
</head>
<body>
    <div class="title-area">
        <h1>雅 - 3D物理抽選機</h1>
        <p>真實碰撞，幸運降臨</p>
    </div>

    <!-- Canvas Container -->
    <div id="canvas-container">
        <!-- Canvas will be inserted here by Three.js -->
    </div>

    <!-- Separate Handle UI element for dragging -->
     <!-- <div class="handle-ui" id="handleUI">
         <div class="handle-ui-knob"></div>
     </div> -->
     <!-- OR an invisible trigger area -->
     <div id="handleDragTrigger"></div>


    <!-- Control Panel (Stays the same) -->
    <div class="control-panel">
        <div class="result-display" id="resultDisplay">準備好了嗎？</div>
        <div>
            <button class="button start" id="startButton">開始抽選</button>
            <button class="button" id="resetButton">重置獎球</button>
        </div>
        <div class="settings-panel">
             <h3>抽選設定</h3>
             <div class="settings-row">
                 <div class="input-group">
                     <label for="ballCount">球數量:</label>
                     <input type="number" id="ballCount" min="5" max="30" value="15"> <!-- Reduced max -->
                 </div>
                 <div class="input-group">
                     <label for="spinSpeed">轉速:</label>
                     <select id="spinSpeed">
                         <option value="0.8">慢</option>
                         <option value="1.0" selected>中</option>
                         <option value="1.3">快</option>
                     </select>
                 </div>
                 <div class="sound-controls">
                    <div class="sound-toggle" id="soundToggle">
                        <i class="fas fa-volume-up"></i> <span id="soundStatus">音效開啟</span>
                    </div>
                </div>
            </div>
         </div>
    </div>

    <!-- Particles & Winner Display (Stays the same) -->
    <div class="particles-container" id="particlesContainer"></div>
    <div class="winner-display" id="winnerDisplay">
        <!-- ... winner content ... -->
    </div>

    <script>
        // Wrap everything in an immediately invoked function expression (IIFE)
        (function() {
            // --- DOM References ---
             const canvasContainer = document.getElementById('canvas-container');
             // Handle UI/Trigger
             // const handleUI = document.getElementById('handleUI'); // If using visual handle
             const handleDragTrigger = document.getElementById('handleDragTrigger'); // If using trigger div
             // Other UI elements... (startButton, resetButton, etc. - same as before)
             const resultDisplay = document.getElementById('resultDisplay');
             const startButton = document.getElementById('startButton');
             const resetButton = document.getElementById('resetButton');
             const ballCountInput = document.getElementById('ballCount');
             const spinSpeedSelect = document.getElementById('spinSpeed');
             const soundToggle = document.getElementById('soundToggle');
             const soundStatus = document.getElementById('soundStatus');
             const particlesContainer = document.getElementById('particlesContainer');
             const winnerDisplay = document.getElementById('winnerDisplay');
             const winnerBall = document.getElementById('winnerBall');
             const winnerMessage = document.getElementById('winnerMessage');
             const closeWinner = document.getElementById('closeWinner');


            // --- Configuration ---
            const config = {
                // Keep ballColors, prizes, particle settings...
                 ballColors: ['#E74C3C', '#3498DB', '#2ECC71', '#F1C40F', '#9B59B6', '#E67E22', '#1ABC9C', '#D35400', '#2980B9', '#27AE60', '#FF7F50', '#6A5ACD', '#FF69B4', '#4682B4', '#CD5C5C'],
                 prizes: [
                    { label: "大吉", color: "#E74C3C", weight: 1 }, { label: "中吉", color: "#E67E22", weight: 2 }, { label: "小吉", color: "#F1C40F", weight: 3 },
                    { label: "吉", color: "#2ECC71", weight: 5 }, { label: "末吉", color: "#3498DB", weight: 8 }, { label: "無念", color: "#95A5A6", weight: 10 }
                 ],
                 particleCount: 60, // Reduced default
                 particleColors: ['#FFD700', '#FFC107', '#FF9800', '#FF69B4', '#FFFFFF'],
                // 3D specific
                machineRadius: 1.0, // Radius of the octagonal drum in meters
                machineHeight: 1.5, // Height of the drum
                ballRadius: 0.1,    // Ball radius in meters
                gravity: -9.82,
                physicsTimeStep: 1 / 60,
                // Spin control
                 handleSensitivity: 1.0,
                 dragInertia: 0.90,
                 minSpinVelocity: 2.0, // Radians per second for physics body
                 baseSpinDuration: 4,
                 spinRandomness: 2,
                 maxSpinSpeedRad: 15, // Max angular velocity (rad/s)
                 // Ejection
                 ejectionImpulse: new CANNON.Vec3(0.5, 1.5, 0), // Impulse to apply to ejected ball
                 ejectionDuration: 1.5 // GSAP animation duration
            };

            // --- State Variables ---
             let isSpinning = false;
             let soundEnabled = true;
             let isLightMode = false; // Add light mode check later if needed
             let balls = []; // Array to hold { mesh: THREE.Mesh, body: CANNON.Body, prize: object }
             let spinTargetSpeed = 0; // Target angular velocity for the drum
             let currentSpinSpeed = 0; // Current angular velocity
             let spinDeceleration = 0.98; // Factor to slow down spin

            // --- Three.js Variables ---
            let scene, camera, renderer, ambientLight, directionalLight;
            let machineGroup; // Group for all machine parts
            let drumMesh;     // Visual drum mesh

            // --- Cannon-es Variables ---
            let world, physicsMaterial, ballMaterial, wallMaterial;
            let drumBody;     // Physics body for the drum container

             // --- Audio (Keep same Howler setup) ---
             const sounds = { /* ... */ };


            // --- Initialization ---
            function init() {
                setupThree();
                setupCannon();
                 // setupDebuggers(); // Optional
                createMachineModel();
                resetLottery(); // Creates initial balls
                setupEventListeners();
                animate(); // Start the animation loop
                console.log("3D抽選機 初始化完成！");
            }

            // --- Three.js Setup ---
            function setupThree() {
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0xFDF6E3); // Match body background

                // Camera (Side View)
                const aspect = canvasContainer.clientWidth / canvasContainer.clientHeight;
                camera = new THREE.PerspectiveCamera(50, aspect, 0.1, 100);
                 // Position for side view: (x, y, z) -> side, slightly above, back
                 camera.position.set(config.machineRadius * 3.5, config.machineHeight * 0.6, 0);
                 camera.lookAt(0, config.machineHeight * 0.2, 0); // Look towards the center-ish
                scene.add(camera);

                // Renderer
                renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                 renderer.shadowMap.enabled = true; // Enable shadows if desired (performance cost)
                 renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                canvasContainer.appendChild(renderer.domElement);

                // Lighting
                ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                scene.add(ambientLight);

                directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(5, 10, 7.5);
                 directionalLight.castShadow = true;
                 // Configure shadow properties if enabled
                 directionalLight.shadow.mapSize.width = 1024;
                 directionalLight.shadow.mapSize.height = 1024;
                 directionalLight.shadow.camera.near = 0.5;
                 directionalLight.shadow.camera.far = 50;
                scene.add(directionalLight);

                 // Optional: Add a helper to visualize the light direction
                 // const lightHelper = new THREE.DirectionalLightHelper(directionalLight, 1);
                 // scene.add(lightHelper);
            }

            // --- Cannon-es Setup ---
            function setupCannon() {
                world = new CANNON.World();
                world.gravity.set(0, config.gravity, 0); // Set gravity
                world.broadphase = new CANNON.NaiveBroadphase(); // Simple broadphase
                // world.solver.iterations = 10; // Adjust solver iterations for accuracy/performance

                // Materials
                physicsMaterial = new CANNON.Material("physics");
                ballMaterial = new CANNON.Material("ball");
                wallMaterial = new CANNON.Material("wall");

                // Contact materials define interactions (friction, restitution/bounciness)
                const ball_physics = new CANNON.ContactMaterial(ballMaterial, physicsMaterial, {
                    friction: 0.1,
                    restitution: 0.6 // Bouncy balls
                });
                const wall_physics = new CANNON.ContactMaterial(wallMaterial, physicsMaterial, {
                    friction: 0.01,
                    restitution: 0.4 // Walls slightly bouncy
                });
                 const ball_ball = new CANNON.ContactMaterial(ballMaterial, ballMaterial, {
                    friction: 0.1,
                    restitution: 0.7 // How bouncy balls are off each other
                });

                world.addContactMaterial(ball_physics);
                world.addContactMaterial(wall_physics);
                 world.addContactMaterial(ball_ball);
            }

             // --- Optional Debuggers ---
             let cannonDebugger;
             function setupDebuggers() {
                 // Cannon-es Debugger
                 // cannonDebugger = new CannonDebugger(scene, world, {
                 //     color: 0x00ff00, // Optional: customize color
                 // });

                 // Orbit Controls (for manual camera movement)
                 // const controls = new OrbitControls(camera, renderer.domElement);
                 // controls.enableDamping = true;
                 // Add controls.update() to the animate loop
             }

            // --- Create 3D Models & Physics Bodies ---
            function createMachineModel() {
                machineGroup = new THREE.Group();
                scene.add(machineGroup);

                // --- 1. Drum (Visual Mesh) ---
                 // Create an octagon cylinder
                const drumGeometry = new THREE.CylinderGeometry(config.machineRadius, config.machineRadius, config.machineHeight, 8, 1, false); // 8 sides
                 const drumMaterial = new THREE.MeshStandardMaterial({
                     color: 0xffffff, // Base color
                     transparent: true,
                     opacity: 0.3,
                     roughness: 0.1,
                     metalness: 0.1,
                     side: THREE.DoubleSide // Render inside and outside
                     // Add wireframe for visual clarity if needed
                     // wireframe: true,
                 });
                drumMesh = new THREE.Mesh(drumGeometry, drumMaterial);
                drumMesh.castShadow = true;
                drumMesh.receiveShadow = true;
                machineGroup.add(drumMesh); // Add visual mesh to the group


                // --- 2. Drum (Physics Body - Kinematic Compound Shape) ---
                 drumBody = new CANNON.Body({
                     mass: 0, // Kinematic body is controlled by animation, not forces
                     type: CANNON.Body.KINEMATIC,
                     material: wallMaterial // Material for drum walls
                 });

                 // Create 8 planes for the octagon sides
                 const angleStep = (Math.PI * 2) / 8;
                 for (let i = 0; i < 8; i++) {
                     const angle = i * angleStep;
                     const planeNormal = new CANNON.Vec3(Math.cos(angle), 0, Math.sin(angle));
                     // Create a plane shape. Position doesn't matter here, only orientation in compound shape.
                     const planeShape = new CANNON.Plane();
                     // Calculate position offset for the plane from the center
                     const planeOffset = new CANNON.Vec3(
                         config.machineRadius * Math.cos(angle),
                         0,
                         config.machineRadius * Math.sin(angle)
                     );
                      // Calculate quaternion to rotate the plane's normal
                     const planeQuat = new CANNON.Quaternion();
                     // Plane normal is (0,0,1) by default. We need to rotate it to face outwards.
                     // Axis is Y-axis. Rotation angle needs to align plane normal with -planeNormal vector calculated above.
                     planeQuat.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), angle - Math.PI/2); // Rotate Y

                     drumBody.addShape(planeShape, new CANNON.Vec3(), planeQuat); // Add rotated plane at the body's origin
                 }

                // Add Top Cap (Plane)
                const topCapShape = new CANNON.Plane();
                const topCapQuat = new CANNON.Quaternion().setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2); // Rotate plane to face down
                drumBody.addShape(topCapShape, new CANNON.Vec3(0, config.machineHeight / 2, 0), topCapQuat);

                // Add Bottom Cap (Plane) - WITH A HOLE conceptually for ejection
                 // We won't add a physical bottom cap initially, letting balls potentially fall through
                 // OR add a temporary one removed later? Let's skip it for now.
                 // If needed:
                 // const bottomCapShape = new CANNON.Plane();
                 // const bottomCapQuat = new CANNON.Quaternion().setFromAxisAngle(new CANNON.Vec3(1, 0, 0), Math.PI / 2); // Rotate plane to face up
                 // drumBody.addShape(bottomCapShape, new CANNON.Vec3(0, -config.machineHeight / 2, 0), bottomCapQuat);


                 world.addBody(drumBody);


                // --- 3. Base and Top Visuals (Simpler Meshes, no physics needed) ---
                const baseMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.8 });
                 const baseGeometry = new THREE.BoxGeometry(config.machineRadius * 2.2, 0.5, config.machineRadius * 2.2); // Example base
                 const baseMesh = new THREE.Mesh(baseGeometry, baseMaterial);
                 baseMesh.position.y = -config.machineHeight / 2 - 0.25; // Position below drum
                 baseMesh.receiveShadow = true;
                 machineGroup.add(baseMesh);

                 // Add simple "chute" visual
                 const chuteMaterial = new THREE.MeshStandardMaterial({ color: 0x555555 });
                 const chuteGeometry = new THREE.BoxGeometry(0.3, 0.4, 0.5);
                 const chuteMesh = new THREE.Mesh(chuteGeometry, chuteMaterial);
                 // Position it where balls should eject (adjust based on side view)
                 chuteMesh.position.set(0, -config.machineHeight / 2 - 0.5, config.machineRadius * 1.1);
                 machineGroup.add(chuteMesh);


                 // --- 4. Handle Visual (Optional, can use UI element) ---
                 // If adding a 3D handle mesh, position it relative to machineGroup
                 // const handleMaterial = new THREE.MeshStandardMaterial({ color: 0xD4AF37 });
                 // ... create handle mesh ...
                 // machineGroup.add(handleMesh);
            }

            // --- Create Balls (3D Mesh + Physics Body) ---
            function createBalls(count) {
                // Clear previous balls
                balls.forEach(ball => {
                    scene.remove(ball.mesh);
                    world.removeBody(ball.body);
                });
                balls = [];

                 let weightedPrizes = [];
                 config.prizes.forEach(prize => { for (let i = 0; i < prize.weight; i++) weightedPrizes.push(prize); });

                const ballGeometry = new THREE.SphereGeometry(config.ballRadius, 16, 12); // Lower poly for performance

                for (let i = 0; i < count; i++) {
                    const prizeData = weightedPrizes[Math.floor(Math.random() * weightedPrizes.length)];

                    // Visual Mesh
                    const ballMesh = new THREE.Mesh(
                        ballGeometry,
                        new THREE.MeshStandardMaterial({
                            color: prizeData.color,
                            roughness: 0.3,
                            metalness: 0.0
                        })
                    );
                    ballMesh.castShadow = true;
                    ballMesh.receiveShadow = true;

                    // Physics Body
                    const ballShape = new CANNON.Sphere(config.ballRadius);
                    const ballBody = new CANNON.Body({
                        mass: 0.1, // Give balls some mass
                        shape: ballShape,
                        material: ballMaterial,
                         position: new CANNON.Vec3(
                             (Math.random() - 0.5) * config.machineRadius * 0.8,
                             config.machineHeight * 0.2 + (Math.random() - 0.5) * config.machineHeight * 0.4, // Start inside drum height
                             (Math.random() - 0.5) * config.machineRadius * 0.8
                         ),
                         angularVelocity: new CANNON.Vec3( (Math.random()-0.5)*5, (Math.random()-0.5)*5, (Math.random()-0.5)*5), // Initial tumble
                         linearDamping: 0.05, // Air resistance
                         angularDamping: 0.05
                    });

                    world.addBody(ballBody);
                    scene.add(ballMesh);

                    balls.push({ mesh: ballMesh, body: ballBody, prize: prizeData });
                }
                console.log(`創建了 ${balls.length} 個 3D 球`);
            }


            // --- Animation Loop ---
            function animate() {
                requestAnimationFrame(animate);
                 const dt = config.physicsTimeStep; // Fixed time step

                // --- Spin Control ---
                 if (isSpinning) {
                     // Approach target speed smoothly (simple lerp)
                     currentSpinSpeed = THREE.MathUtils.lerp(currentSpinSpeed, spinTargetSpeed, 0.1);

                     // Apply deceleration if target is 0
                     if (spinTargetSpeed === 0 && Math.abs(currentSpinSpeed) > 0.01) {
                         currentSpinSpeed *= spinDeceleration;
                     } else if (spinTargetSpeed === 0 && Math.abs(currentSpinSpeed) <= 0.01) {
                         currentSpinSpeed = 0;
                         // Spin has effectively stopped
                         if (isSpinning) { // Check again in case stopSpinning was already called
                             stopSpinning();
                         }
                     }
                 } else {
                     // Ensure speed goes to zero when not spinning
                     currentSpinSpeed = THREE.MathUtils.lerp(currentSpinSpeed, 0, 0.1);
                     if (Math.abs(currentSpinSpeed) < 0.01) currentSpinSpeed = 0;
                 }

                 // Update Kinematic Drum Body's rotation based on current speed
                 if (drumBody && Math.abs(currentSpinSpeed) > 0) {
                      // Integrate angular velocity manually for kinematic body
                      const currentQuat = drumBody.quaternion;
                      const deltaQuat = new CANNON.Quaternion();
                      deltaQuat.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), currentSpinSpeed * dt); // Rotate around Y axis
                      drumBody.quaternion = deltaQuat.mult(currentQuat); // Apply rotation delta
                 }


                // Step the physics world
                world.step(dt);

                // Update visual meshes from physics bodies
                balls.forEach(ball => {
                    ball.mesh.position.copy(ball.body.position);
                    ball.mesh.quaternion.copy(ball.body.quaternion);
                });

                 // Update visual drum mesh from physics drum body
                 if (drumMesh && drumBody) {
                     drumMesh.position.copy(drumBody.position); // Should be 0,0,0 if not moving
                     drumMesh.quaternion.copy(drumBody.quaternion);
                 }

                 // Update optional debuggers
                 if (cannonDebugger) cannonDebugger.update();
                 // if (controls) controls.update(); // If using OrbitControls

                // Render the scene
                renderer.render(scene, camera);
            }

            // --- Event Listeners & Interaction ---
             function setupEventListeners() {
                 startButton.addEventListener('click', handleSpinButtonClick);
                 resetButton.addEventListener('click', handleResetClick);
                 soundToggle.addEventListener('click', toggleSound);
                 closeWinner.addEventListener('click', hideWinnerDisplay);

                 // --- Handle Dragging (using trigger div) ---
                 let dragStartY = 0;
                 let handleVelocity = 0; // Represents the drag velocity

                 Draggable.create(handleDragTrigger, {
                     type: "y", // Drag vertically
                     trigger: handleDragTrigger,
                     inertia: true,
                     throwResistance: 3000, // Adjust friction
                      // bounds: { minY: -100, maxY: 100 }, // Optional bounds
                     onDragStart: function() {
                         if (isSpinning) return;
                         dragStartY = this.y;
                         handleVelocity = 0;
                          if (sounds.click && soundEnabled) sounds.click.play();
                         // Optional visual feedback on the handle UI if used
                         // gsap.to(handleUI, { scaleY: 1.1, duration: 0.1 });
                     },
                     onDrag: function() {
                         // Calculate velocity during drag
                         handleVelocity = this.getVelocity("y");
                          // Optional visual feedback
                          // gsap.set(handleUI, { y: this.y * 0.2 }); // Move UI handle slightly
                     },
                     onThrowUpdate: function() {
                          handleVelocity = this.getVelocity("y");
                          // Optional visual feedback during throw
                     },
                     onDragEnd: function() {
                         // Final velocity from throw
                         handleVelocity = this.getVelocity("y");
                         console.log("Drag End Velocity (Y):", handleVelocity);

                         // Optional visual feedback reset
                         // gsap.to(handleUI, { scaleY: 1, y: 0, duration: 0.3 });
                          // Reset draggable's position visually if needed
                          gsap.to(this.target, { y: 0, duration: 0.5, ease: "elastic.out(1, 0.5)" });


                         // Convert vertical velocity to angular velocity for the drum
                         const angularVelFromDrag = -handleVelocity * 0.02 * config.handleSensitivity; // Adjust scaler
                         console.log("Calculated Angular Vel:", angularVelFromDrag);


                         if (Math.abs(angularVelFromDrag) > config.minSpinVelocity && !isSpinning) {
                             console.log("手把拖曳結束，啟動慣性旋轉");
                             startSpin(angularVelFromDrag, config.baseSpinDuration + Math.random() * config.spinRandomness); // Pass initial velocity
                         } else {
                             console.log("手把拖曳結束，速度不足");
                         }
                     }
                 });

                  window.addEventListener('resize', onWindowResize, false);
             }

             function onWindowResize() {
                 const w = canvasContainer.clientWidth;
                 const h = canvasContainer.clientHeight;
                 camera.aspect = w / h;
                 camera.updateProjectionMatrix();
                 renderer.setSize(w, h);
             }


            // --- Spin Logic ---
             function startSpin(initialVelocityRad = 0, duration) {
                 if (isSpinning) return;
                 isSpinning = true;
                 setControlsDisabled(true);
                 resultDisplay.textContent = '幸運轉動中...';
                 resultDisplay.classList.remove('winning');

                 if (soundEnabled) sounds.spin.play();

                 // Set target speed based on speed setting and initial velocity
                 const speedFactor = parseFloat(spinSpeedSelect.value);
                  // Combine initial velocity with a base speed, capping it
                 spinTargetSpeed = THREE.MathUtils.clamp(
                     Math.abs(initialVelocityRad) + (config.maxSpinSpeedRad * 0.5 * speedFactor), // Base speed + initial boost
                     config.minSpinVelocity * speedFactor, // Minimum speed
                     config.maxSpinSpeedRad * speedFactor // Maximum speed
                 );
                 // Make direction consistent (e.g., always positive Y rotation)
                 spinTargetSpeed = Math.sign(initialVelocityRad || 1) * spinTargetSpeed;


                 console.log("Target Spin Speed (rad/s):", spinTargetSpeed);

                 // Set current speed towards target (can start immediately or ramp up)
                 currentSpinSpeed = initialVelocityRad; // Start with the drag velocity

                 // Set timeout to start deceleration
                 const spinTime = (duration + Math.random() * config.spinRandomness) * 1000;
                 setTimeout(() => {
                     if (isSpinning) {
                         console.log("開始減速...");
                         spinTargetSpeed = 0; // Target speed becomes zero to trigger deceleration
                     }
                 }, spinTime);

                 // GSAP animation for spotlight (visual only)
                 gsap.to( /* spotlight element if used */ '#canvas-container', { // Example target
                      // Fake spotlight effect with box-shadow or overlay?
                      boxShadow: "inset 0 0 100px 50px rgba(255, 255, 200, 0.4)",
                      duration: 0.5,
                      yoyo: true,
                      repeat: -1, // Loop while spinning
                      repeatDelay: 0.2
                  });
             }


             function stopSpinning() {
                 if (!isSpinning) return; // Prevent double calls
                 isSpinning = false; // Set state immediately
                 spinTargetSpeed = 0; // Ensure target is 0
                 // currentSpinSpeed will decelerate in the animation loop

                 if (sounds.spin.playing()) sounds.spin.stop();

                 console.log("停止旋轉，等待球體穩定...");

                  // Kill spotlight animation
                  gsap.killTweensOf('#canvas-container'); // Kill fake spotlight tween
                  gsap.to('#canvas-container', { boxShadow: "0 5px 15px rgba(0,0,0,0.1)", duration: 0.5 });


                 // Wait for balls to settle, then determine winner
                 setTimeout(determineWinner, 1500); // Wait 1.5 seconds
             }

             function determineWinner() {
                  if (isSpinning) return; // Don't determine if somehow spin restarted

                  let winner = null;
                  let lowestY = Infinity;

                  balls.forEach(ball => {
                      if (ball.body.position.y < lowestY) {
                          lowestY = ball.body.position.y;
                          winner = ball;
                      }
                  });

                  if (winner) {
                      console.log(`中獎！獎品: ${winner.prize.label}`);
                      displayResult(winner);
                       ejectBall(winner); // Trigger ejection animation
                  } else {
                      resultDisplay.textContent = "抽選出錯";
                      setControlsDisabled(false);
                  }
             }


            // --- Display Result & Ejection ---
             function displayResult(winner) {
                 resultDisplay.textContent = `恭喜！抽中 ${winner.prize.label}！`;
                 resultDisplay.classList.add('winning');
                 // resultDisplay.style.borderColor = winner.prize.color; // Keep if desired

                 if (soundEnabled) sounds.win.play();
                 triggerParticleEffect(winner.mesh); // Trigger particles from the 3D mesh's screen position
                 showWinnerDisplay(winner); // Show the modal

                 // Controls are re-enabled AFTER ejection animation finishes
             }

             function ejectBall(winner) {
                 console.log("彈出球:", winner.prize.label);

                 // 1. Remove physics body so it's no longer simulated
                 world.removeBody(winner.body);

                 // 2. Define ejection path using GSAP
                 const ejectPath = [
                     // Move towards chute area (adjust Z based on view)
                     { x: 0, y: -config.machineHeight / 2 - 0.1, z: config.machineRadius * 1.1, duration: 0.5, ease: "power1.in" },
                     // Fall down
                     { y: -config.machineHeight, duration: 0.8, ease: "bounce.out" } // Use bounce ease
                 ];

                 // Create GSAP timeline for the mesh animation
                 const tl = gsap.timeline({
                     onComplete: () => {
                         console.log("球彈出動畫完成");
                          setControlsDisabled(false); // Re-enable controls now

                          // Optional: Hide the ejected ball after a delay
                          // gsap.to(winner.mesh.scale, { x: 0, y: 0, z: 0, duration: 0.3, delay: 1 });
                     }
                 });

                 // Animate the THREE.Mesh position
                 tl.to(winner.mesh.position, ejectPath[0]);
                 tl.to(winner.mesh.position, ejectPath[1]);

                  // Optional: Add a little spin while falling
                  gsap.to(winner.mesh.rotation, {
                      x: Math.random() * 4 - 2,
                      z: Math.random() * 4 - 2,
                      duration: config.ejectionDuration,
                      ease: "none"
                  });
             }


             // --- Helper Functions (Keep setControlsDisabled, toggleSound, particle effect, winner display etc.) ---
              function setControlsDisabled(disabled) {
                 startButton.disabled = disabled;
                 resetButton.disabled = disabled;
                 handleDragTrigger.style.pointerEvents = disabled ? 'none' : 'auto';
                 handleDragTrigger.style.cursor = disabled ? 'not-allowed' : 'grab';
                  if (Draggable.get(handleDragTrigger)) {
                      Draggable.get(handleDragTrigger)[disabled ? 'disable' : 'enable']();
                  }
             }
             function toggleSound() { /* ... Keep same ... */ }
             function triggerParticleEffect(targetMesh) {
                  if (isLightMode) return;

                  // Project 3D position to 2D screen coordinates
                  const screenPos = toScreenPosition(targetMesh, camera, canvasContainer);

                 for (let i = 0; i < config.particleCount; i++) { /* ... Keep particle creation/animation logic ... */
                      // Use screenPos.x and screenPos.y as the startX, startY
                      gsap.set(particle, { x: screenPos.x, y: screenPos.y, /* ... other props */ });
                      // Animate particles...
                  }
                 console.log("觸發粒子特效 at", screenPos);
             }
             // Helper to convert 3D position to 2D screen coordinates
              function toScreenPosition(obj, camera, rendererContainer) {
                  const vector = new THREE.Vector3();
                  const widthHalf = 0.5 * rendererContainer.clientWidth;
                  const heightHalf = 0.5 * rendererContainer.clientHeight;

                  obj.updateMatrixWorld(); // Make sure the object's matrix is up to date
                  vector.setFromMatrixPosition(obj.matrixWorld); // Get world position
                  vector.project(camera); // Project to normalized device coordinates (-1 to +1)

                  const x = (vector.x * widthHalf) + widthHalf;
                  const y = -(vector.y * heightHalf) + heightHalf;

                  // Get position relative to the container's top-left corner
                   const rect = rendererContainer.getBoundingClientRect();
                   const offsetX = rect.left + window.scrollX;
                   const offsetY = rect.top + window.scrollY;


                  return {
                      x: x + offsetX,
                      y: y + offsetY,
                  };
              }


             function showWinnerDisplay(winner) { /* ... Keep same ... */ }
             function hideWinnerDisplay() { /* ... Keep same ... */ }


            // --- Reset ---
             function resetLottery() {
                 // Stop any ongoing spin/animation
                 isSpinning = false;
                 spinTargetSpeed = 0;
                 currentSpinSpeed = 0;
                  gsap.killTweensOf('#canvas-container'); // Kill spotlight
                  gsap.to('#canvas-container', { boxShadow: "0 5px 15px rgba(0,0,0,0.1)", duration: 0.1 });


                 // Reset physics drum rotation
                 if (drumBody) {
                      drumBody.quaternion.set(0, 0, 0, 1); // Reset rotation
                      drumBody.angularVelocity.set(0, 0, 0); // Stop any residual velocity
                 }
                  // Reset visual drum mesh
                  if (drumMesh) {
                      drumMesh.quaternion.set(0, 0, 0, 1);
                  }


                 // Recreate balls
                 const ballCount = parseInt(ballCountInput.value, 10);
                 if (isNaN(ballCount) || ballCount < 5 || ballCount > 30) {
                      ballCountInput.value = 15;
                      createBalls(15);
                  } else {
                     createBalls(ballCount);
                 }

                 resultDisplay.textContent = "準備開始抽選";
                 resultDisplay.classList.remove('winning');
                 hideWinnerDisplay();
                 setControlsDisabled(false);
             }

            // --- Start Application ---
            init();

        })(); // End IIFE
    </script>
</body>
</html>