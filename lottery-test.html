<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>御縁の抽選機 - 日式八角抽選機</title>
    <!-- 引入字體 -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&family=Noto+Serif+JP:wght@400;700&display=swap" rel="stylesheet">
    <!-- 引入 GSAP 動畫庫 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
    <!-- 引入 Howler.js 音效庫 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.4/howler.min.js"></script>
    <!-- 引入 FontAwesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
    <style>
        :root {
            --primary: #B28046;
            --primary-light: #D4AF6A;
            --primary-dark: #8C5E2A;
            --accent: #9E2A2B;
            --background: #F5F5F0;
            --text: #33281E;
            --glass: rgba(255, 255, 255, 0.25);
            --gold-gradient: linear-gradient(135deg, #D4AF37 0%, #F1DB8B 40%, #F8F4E3 50%, #F1DB8B 60%, #D4AF37 100%);
            --wooden-gradient: linear-gradient(135deg, #8B4513 0%, #A0522D 50%, #8B4513 100%);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Noto Sans TC', sans-serif;
            background-color: var(--background);
            background-image: 
                radial-gradient(circle at 100% 0%, rgba(178, 128, 70, 0.15) 0%, transparent 60%), 
                radial-gradient(circle at 0% 100%, rgba(158, 42, 43, 0.1) 0%, transparent 50%);
            color: var(--text);
            overflow-x: hidden;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            padding: 20px;
        }
        
        .title-area {
            text-align: center;
            margin-bottom: 20px;
            padding: 10px;
            position: relative;
            z-index: 10;
        }
        
        .title-area h1 {
            font-family: 'Noto Serif JP', serif;
            font-size: 2.5rem;
            color: var(--primary-dark);
            margin-bottom: 5px;
            letter-spacing: 2px;
            position: relative;
            display: inline-block;
        }
        
        .title-area h1::after {
            content: '';
            position: absolute;
            bottom: -8px;
            left: 10%;
            width: 80%;
            height: 2px;
            background: var(--gold-gradient);
        }
        
        .title-area p {
            font-size: 1rem;
            color: var(--text);
            opacity: 0.8;
        }
        
        /* 主要抽選機容器 */
        .lottery-scene {
            position: relative;
            width: 100%;
            max-width: 800px; /* 增加寬度容納手把 */
            height: 600px; /* 增加高度 */
            perspective: 1200px;
            margin: 0 auto;
            /* outline: 1px dashed red; */ /* Debug: 顯示邊界 */
        }
        
        /* 八角形抽選機 */
        .lottery-machine {
            position: absolute;
            top: 50%;
            left: 50%;
            /* 調整中心點 */
            transform: translate(-50%, -50%) rotateX(10deg);
            transform-style: preserve-3d;
            width: 320px; /* 八角柱直徑相關 */
            height: 320px; /* 八角柱高度 */
            transition: transform 0.5s ease;
            /* outline: 1px dashed blue; */ /* Debug: 顯示邊界 */
        }
        
        .octagon {
            position: absolute;
            width: 100%; /* 與 .lottery-machine 相同 */
            height: 100%; /* 與 .lottery-machine 相同 */
            transform-style: preserve-3d;
        }
        
        /* 八個面 */
        .octagon-face {
            position: absolute;
            /* 調整 positioning 使中心對齊 lottery-machine 中心 */
            top: 0;
            left: calc(50% - 70px); /* (320 - 140) / 2 = 90 不對, 應該是 (父寬度 - 自身寬度) / 2 */
                                     /* left: calc(50% - 70px);  => width 140px, 所以 left = 50% - 70px */
            width: 140px; /* 面寬 */
            height: 320px; /* 面高 = 八角柱高 */
            background: var(--glass);
            border: 2px solid var(--primary-light);
            backdrop-filter: blur(5px);
            box-shadow: inset 0 0 15px rgba(255, 255, 255, 0.5);
            /* 旋轉和位移的原點設在父容器中心 */
            transform-origin: center center;
            transform-style: preserve-3d;
            overflow: hidden; /* 隱藏超出邊界的球 */
        }
        
        .octagon-face::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, 
                        rgba(255, 255, 255, 0.4) 0%, 
                        rgba(255, 255, 255, 0.1) 50%, 
                        rgba(255, 255, 255, 0) 100%);
            pointer-events: none;
        }
        
        /* 八角形頂部與底部 */
        .top-cap, .bottom-cap {
            position: absolute;
            /* 寬高應約等於八角柱的外接圓直徑, 或略大 */
            /* 外接圓半徑 R = a / cos(pi/8) = 140 / cos(22.5) ≈ 151.5 */
            /* 直徑 ≈ 303px. 邊長 s = 2 * a * tan(pi/8) = 2 * 140 * tan(22.5) ≈ 116 */
            /* 此處 260px 是一個視覺選擇 */
            width: 282px; /* 根據 translateZ=140 計算的邊到邊距離約 2*140 = 280 */
            height: 282px;
            left: 50%;
            /* X軸旋轉90度成為平面 */
            transform: translateX(-50%) rotateX(90deg);
            background: var(--gold-gradient);
            /* 改成八角形 */
            clip-path: polygon(30% 0%, 70% 0%, 100% 30%, 100% 70%, 70% 100%, 30% 100%, 0% 70%, 0% 30%);
            /* border-radius: 50%; */ /* 改用 clip-path */
            transform-style: preserve-3d;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
        }
        
        .top-cap {
            /* Z 軸位移 = 八角柱高度 / 2 */
            transform: translateX(-50%) rotateX(90deg) translateZ(160px);
            background-image: var(--gold-gradient);
        }
        
        /* 頂部裝飾移除或修改 */
        /* .top-cap::after { ... } */
        
        .bottom-cap {
            /* Z 軸位移 = - 八角柱高度 / 2 */
            transform: translateX(-50%) rotateX(90deg) translateZ(-160px);
            background-image: var(--wooden-gradient);
        }
        
        /* 手把 */
        .handle-container {
            position: absolute;
            width: 40px;
            height: 300px;
            /* 放在抽選機右側外部 */
            right: -120px; /* 調整位置使其不重疊 */
            top: 50%;
            transform: translateY(-50%);
            cursor: grab;
            z-index: 5;
            transform-style: preserve-3d;
             /* outline: 1px dashed green; */ /* Debug: 顯示邊界 */
        }
        
        .handle {
            position: absolute;
            width: 40px;
            height: 200px;
            background-color: var(--primary-dark);
            border-radius: 20px;
            bottom: 30px; /* 抬高一點以容納底座 */
            /* 旋轉中心在底部 */
            transform-origin: bottom center;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
        }
        
        .handle-knob {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: var(--gold-gradient);
            top: -30px; /* 旋鈕中心對齊手把頂部 */
            left: 50%;
            transform: translateX(-50%);
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.4);
            border: 3px solid #D4AF37;
        }
        
        .handle-base {
            position: absolute;
            width: 80px;
            height: 40px;
            background: var(--wooden-gradient);
            border-radius: 10px;
            bottom: 0px; /* 手把底部 */
            left: 50%;
            transform: translateX(-50%);
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.2);
        }
        
        /* 抽選球 */
        .ball {
            position: absolute;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            text-align: center;
            line-height: 40px;
            font-weight: bold;
            font-size: 1rem; /* 稍微縮小字體以適應球大小 */
            transform-style: preserve-3d;
            box-shadow: inset 0 0 8px rgba(0, 0, 0, 0.2), 0 0 4px rgba(0, 0, 0, 0.3);
            color: white;
            text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.5);
            /* 初始位置由 JS 設定 */
            /* 球的 transform-origin 應在中心 */
            transform-origin: center center;
            /* 添加 will-change 提升動畫效能 */
            will-change: transform, opacity;
        }
        
        /* 控制面板 */
        .control-panel {
            position: relative;
            width: 100%;
            max-width: 600px;
            margin: 30px auto 0; /* 調整 margin-top */
            padding: 20px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            text-align: center;
            border: 1px solid var(--primary-light);
            z-index: 20;
        }
        
        .result-display {
            font-size: 1.5rem;
            font-weight: bold;
            margin: 15px 0;
            padding: 10px;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 5px;
            background-color: rgba(245, 245, 240, 0.7);
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.1);
            color: var(--text);
            transition: background-color 0.5s, color 0.5s;
        }
        
        .result-display.winning {
            background-color: var(--primary-light);
            color: var(--text);
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.1), 0 0 0 0 rgba(178, 128, 70, 0.4); }
            70% { box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.1), 0 0 0 10px rgba(178, 128, 70, 0); }
            100% { box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.1), 0 0 0 0 rgba(178, 128, 70, 0); }
        }
        
        .button {
            background: var(--primary);
            color: white;
            border: none;
            padding: 12px 25px;
            font-size: 1rem;
            border-radius: 30px;
            cursor: pointer;
            margin: 5px;
            font-weight: 500;
            letter-spacing: 1px;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.15);
            transition: all 0.3s ease;
            font-family: 'Noto Sans TC', sans-serif;
        }
        
        .button:hover {
            background: var(--primary-dark);
            transform: translateY(-2px);
            box-shadow: 0 5px 12px rgba(0, 0, 0, 0.2);
        }
        
        .button.start {
            background: var(--accent);
        }
        
        .button.start:hover {
            background: #7D2122;
        }
        
        .button:disabled {
            background: #cccccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            opacity: 0.7;
        }
        
        /* 設定面板 */
        .settings-panel {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(0, 0, 0, 0.1);
        }
        
        .settings-panel h3 {
            margin-bottom: 10px;
            font-size: 1.1rem;
            color: var(--text);
        }
        
        .settings-row {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 10px;
        }
        
        .input-group {
            display: flex;
            align-items: center;
        }
        
        .input-group label {
            margin-right: 8px;
            font-size: 0.9rem;
        }
        
        .input-group input, .input-group select {
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #ddd;
            font-family: inherit;
            min-width: 70px; /* 避免過窄 */
        }
        
        /* 粒子效果 */
        .particles-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 30;
            overflow: hidden;
        }
        
        .particle {
            position: absolute;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            opacity: 0;
            will-change: transform, opacity; /* 提升動畫效能 */
        }
        
        /* 燈光效果 */
        .spotlight {
            position: absolute;
            /* 調整位置和大小，使其聚焦於機器 */
            top: 50%;
            left: 50%;
            width: 500px; /* 稍微縮小 */
            height: 500px;
            transform: translate(-50%, -50%); /* 中心對齊 */
            background: radial-gradient(
                ellipse at center,
                rgba(255, 255, 220, 0.5) 0%, /* 稍微偏黃的光 */
                rgba(255, 255, 255, 0) 70%
            );
            border-radius: 50%; /* 確保是圓形 */
            pointer-events: none;
            opacity: 0;
            z-index: 2; /* 放在機器後面但在背景之上 */
            transition: opacity 1s ease; /* 使用 CSS transition */
        }
        
        /* 獎項顯示區 */
        .winner-display {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }
        
        .winner-display.show {
            opacity: 1;
            pointer-events: auto;
        }
        
        .winner-content {
            background: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            max-width: 80%;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
            transform: scale(0.8);
            transition: transform 0.5s ease;
        }
        
        .winner-display.show .winner-content {
            transform: scale(1);
        }
        
        .winner-ball {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            margin: 0 auto 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.5rem;
            font-weight: bold;
            color: white;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.5);
            transition: background-color 0.3s;
        }
        
        .winner-title {
            font-size: 1.8rem;
            color: var(--accent);
            margin-bottom: 10px;
            font-family: 'Noto Serif JP', serif;
        }
        
        .winner-message {
            font-size: 1.2rem;
            margin-bottom: 20px;
        }
        
        .close-button {
            background: var(--primary);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 30px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s ease;
        }
        
        .close-button:hover {
            background: var(--primary-dark);
        }
        
        /* 音效控制 */
        .sound-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-top: 10px;
        }
        
        .sound-toggle {
            display: flex;
            align-items: center;
            margin-left: 15px;
            cursor: pointer;
            user-select: none; /* 防止文字被選取 */
        }
        
        .sound-toggle i {
            margin-right: 5px;
            color: var(--primary);
            width: 1.2em; /* 固定圖標寬度 */
            text-align: center;
        }
        
        /* 響應式設計 */
        @media (max-width: 767px) {
            body {
                padding: 10px; /* 減少邊距 */
            }
            .title-area h1 {
                font-size: 1.8rem;
            }
            .title-area p {
                font-size: 0.9rem;
            }
            .lottery-scene {
                height: 450px;
                max-width: 100%;
                perspective: 1000px; /* 減少透視 */
            }
            
            .lottery-machine {
                width: 240px; /* 縮小機器 */
                height: 240px;
            }
            
            .octagon-face {
                width: 100px; /* 縮小面寬 */
                height: 240px; /* 縮小面高 */
                left: calc(50% - 50px); /* 重新計算 left */
                /* translateZ 需要根據新的寬度和八角形要求重新計算 */
                /* 如果保持八角形, translateZ = (100 / 2) / tan(pi / 8) ≈ 120.7 */
                /* 使用 100px 保持比例 */
                transform: rotateY(0deg) translateZ(100px); /* JS 會覆蓋 rotateY */
            }

            .top-cap, .bottom-cap {
                /* 根據新的 translateZ=100 計算 */
                width: 200px;
                height: 200px;
                 /* clip-path 保持不變 */
            }
            .top-cap {
                transform: translateX(-50%) rotateX(90deg) translateZ(120px); /* height/2 */
            }
            .bottom-cap {
                 transform: translateX(-50%) rotateX(90deg) translateZ(-120px); /* -height/2 */
            }
            
            .handle-container {
                right: -60px; /* 靠近一點 */
                height: 220px; /* 縮小 */
            }
            
            .handle {
                height: 150px; /* 縮小 */
                bottom: 20px;
            }
             .handle-knob {
                width: 50px;
                height: 50px;
                top: -25px;
            }
            .handle-base {
                width: 60px;
                height: 30px;
                bottom: 0px;
            }

            .ball {
                width: 30px;
                height: 30px;
                line-height: 30px;
                font-size: 0.8rem; /* 縮小字體 */
            }
            
            .control-panel {
                padding: 15px;
                margin-top: 20px;
            }
            .result-display {
                font-size: 1.2rem;
                min-height: 50px;
            }
             .button {
                padding: 10px 20px;
                font-size: 0.9rem;
            }

            .settings-row {
                flex-direction: column;
                align-items: stretch;
                gap: 10px;
            }
            .input-group {
                justify-content: space-between;
            }
            .input-group input, .input-group select {
                padding: 6px;
                flex-grow: 1; /* 讓輸入框填滿空間 */
                margin-left: 10px;
            }

            .winner-content {
                padding: 20px;
                max-width: 90%; /* 稍微增加寬度 */
            }
            .winner-ball {
                width: 80px;
                height: 80px;
                font-size: 2rem;
            }
             .winner-title {
                font-size: 1.5rem;
            }
            .winner-message {
                font-size: 1rem;
            }
            .close-button {
                padding: 8px 16px;
                font-size: 0.9rem;
            }
        }
        
        /* 輕量模式的樣式 */
        body.light-mode .octagon-face {
            backdrop-filter: none; /* 移除模糊效果 */
            background: rgba(212, 175, 106, 0.5); /* 使用半透明純色替代 */
        }
        body.light-mode .ball {
             box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.1); /* 簡化陰影 */
        }

    </style>
</head>
<body>
    <!-- 標題區域 -->
    <div class="title-area">
        <h1>御縁の抽選機</h1>
        <p>緣分天注定，運勢在此時</p>
    </div>
    
    <!-- 主要抽選機場景 -->
    <div class="lottery-scene">
        <!-- 燈光效果 -->
        <div class="spotlight"></div>
        
        <!-- 八角形抽選機 -->
        <div class="lottery-machine">
            <div class="octagon" id="octagon">
                <!-- 八個面會被JS動態生成 -->
            </div>
            <div class="top-cap"></div>
            <div class="bottom-cap"></div>
        </div>
        
        <!-- 手把 -->
        <div class="handle-container" id="handleContainer">
            <div class="handle">
                <div class="handle-knob"></div>
            </div>
            <div class="handle-base"></div>
        </div>
    </div>
    
    <!-- 控制面板 -->
    <div class="control-panel">
        <div class="result-display" id="resultDisplay">
            準備開始抽選...
        </div>
        <div>
            <button class="button start" id="startButton">開始抽選</button>
            <button class="button" id="resetButton">重新設置</button>
        </div>
        
        <!-- 設定面板 -->
        <div class="settings-panel">
            <h3>抽選設定</h3>
            <div class="settings-row">
                <div class="input-group">
                    <label for="ballCount">球數量:</label>
                    <input type="number" id="ballCount" min="5" max="30" value="15">
                </div>
                <div class="input-group">
                    <label for="spinSpeed">轉速:</label>
                    <select id="spinSpeed">
                        <option value="slow">慢速</option>
                        <option value="medium" selected>中速</option>
                        <option value="fast">快速</option>
                    </select>
                </div>
                <div class="sound-controls">
                    <div class="sound-toggle" id="soundToggle">
                        <i class="fas fa-volume-up"></i> <span id="soundStatus">音效開啟</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- 粒子效果容器 -->
    <div class="particles-container" id="particlesContainer"></div>
    
    <!-- 獎項顯示區 -->
    <div class="winner-display" id="winnerDisplay">
        <div class="winner-content">
            <div class="winner-ball" id="winnerBall"></div>
            <h2 class="winner-title">恭喜中獎！</h2>
            <p class="winner-message" id="winnerMessage">您抽中了神秘獎項！</p>
            <button class="close-button" id="closeWinner">確認</button>
        </div>
    </div>
    
    <!-- JavaScript -->
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // --- DOM Elements ---
            const octagonContainer = document.getElementById('octagon');
            const handleContainer = document.getElementById('handleContainer');
            const handle = handleContainer.querySelector('.handle');
            const resultDisplay = document.getElementById('resultDisplay');
            const startButton = document.getElementById('startButton');
            const resetButton = document.getElementById('resetButton');
            const ballCountInput = document.getElementById('ballCount');
            const spinSpeedSelect = document.getElementById('spinSpeed');
            const soundToggle = document.getElementById('soundToggle');
            const soundStatus = document.getElementById('soundStatus');
            const particlesContainer = document.getElementById('particlesContainer');
            const spotlight = document.querySelector('.spotlight');
            const winnerDisplay = document.getElementById('winnerDisplay');
            const winnerBall = document.getElementById('winnerBall');
            const winnerMessage = document.getElementById('winnerMessage');
            const closeWinner = document.getElementById('closeWinner');
            const lotteryMachine = document.querySelector('.lottery-machine'); // Get machine element
            
            // --- State Variables ---
            let isSpinning = false;
            let currentSpinSpeed = 0; // Renamed from spinSpeed to avoid conflict with select value
            let spinAngle = 0;
            let balls = [];
            let soundEnabled = true;
            let isLightMode = false;
            let dragStartY = 0;
            let handleAngle = 0;
            let handleVelocity = 0;
            let lastDragY = 0;
            let isDragging = false;
            let animationFrameId = null; // To store requestAnimationFrame ID
            let spinStartTime = 0; // To track spin duration
            let isDecelerating = false; // Flag to control deceleration phase

            // --- Constants ---
            const DECELERATION_FACTOR = 0.995;
            const MIN_SPIN_SPEED = 0.1;
            const HANDLE_DRAG_THRESHOLD = 10;
            const SPIN_DURATION_BEFORE_DECEL = 3000 + Math.random() * 2000; // 3-5 seconds
            const BALL_DIAMETER = 40; // Should match ball CSS width/height
            const BALL_RADIUS = BALL_DIAMETER / 2;

             // --- Physics Constants ---
            const GRAVITY = 0.03; // Slightly increased gravity
            const FRICTION = 0.98;
            const BOUNDARY_ELASTICITY = 0.7; // Reduced elasticity
            const BALL_COLLISION_DAMPING = 0.85; // Damping for ball collisions

            // --- Prize Definitions ---
            const prizes = [
                { label: "大吉", color: "#E74C3C", weight: 1 },
                { label: "中吉", color: "#E67E22", weight: 2 },
                { label: "小吉", color: "#F1C40F", weight: 3 },
                { label: "吉", color: "#2ECC71", weight: 5 },
                { label: "末吉", color: "#3498DB", weight: 8 },
                { label: "凶", color: "#9B59B6", weight: 3 },
                { label: "大凶", color: "#34495E", weight: 1 }
            ];
            
            // --- Sound Effects ---
            // Ensure Base64 strings are correct or replace with file paths
            const sounds = {
                spin: new Howl({
                    src: ['data:audio/mp3;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU4Ljc2LjEwMAAAAAAAAAAAAAAA//tQwAAAAAAAAAAAAAAAAAAAAAAASW5mbwAAAA8AAAASAAAeMwAUFBQUHh4eHh4qKioqKioqNDQ0NDRAQEBAQEBMTExMTExMWFhYWFhkZGRkZGRwcHBwcHB8fHx8fHyIiIiIiIiIlJSUlJSUnJycnJyouLi4uLi4xMTExMTE0NDQ0NDQ0NDc3Nzc3Nzc6Ojo6Oj09PT09PT///8AAAAATGF2YzU4LjEzAAAAAAAAAAAAAAAAJAQoAAAAAAAeMwGvI84AAAAAAAAAAAAAAAAA//uQwAALcABEnCAAACNCwQnG8gAQAYRERERERERRAAIR5zjn5uecIQhEQnOOcABAIBAMBAIThCcIQhCEIQiIiIiRERERI='],
                    volume: 0.4, // Slightly lower volume
                    loop: true
                }),
                win: new Howl({
                    src: ['data:audio/mp3;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU4Ljc2LjEwMAAAAAAAAAAAAAAA//tQwAAAAAAAAAAAAAAAAAAAAAAASW5mbwAAAA8AAAAeAAAyQAAFBQsLERERFxwcHCIiIigvLy8vNTU1Ozs7O0FBQUdNTU1NUlJSWFhYWF5eXmRpaWlpcG9vdnZ2dnx8fIKCgoKIiIiOlJSUlJqamp+fn5+mp6enrKyssbGxscbGxs3NzdLY2Nja4ODg4Obj4+no6Ojv7+/v9PT0+fn5+f///wAAAExhdmM1OC4xMwAAAAAAAAAAAAAAACQEKQAAAAAAAAAAAAAAAA//+xDEAAPAAAGkAAAAIAAANIAAAARMQU1FMy45OS41VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7IMQFg8AAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVQ=='],
                    volume: 0.7
                }),
                click: new Howl({
                    src: ['data:audio/mp3;base64,SUQzAwAAAAAAJlRQRTEAAAAcAAAAU291bmRKYXkuY29tIFNvdW5kIEVmZmVjdHMA//uQxAADwAABpAAAACAAADSAAAAETEFNRTMuOTkuNVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVU='],
                    volume: 0.6
                }),
                bounce: new Howl({
                    src: ['data:audio/mp3;base64,SUQzAwAAAAAAJlRQRTEAAAAcAAAAU291bmRKYXkuY29tIFNvdW5kIEVmZmVjdHMA//uUxAADwAABpAAAACAAADSAAAAETEFNRTMuOTkuNVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVU='],
                    volume: 0.3, // Lower volume for bounces
                    pool: 5 // Allow multiple bounce sounds
                })
            };
            
            // --- Utility Functions ---
            
            // Check device performance for light mode
            function checkDevicePerformance() {
                const isMobile = window.innerWidth <= 767;
                // More robust check: consider memory, not just cores
                const isLowPerformance = isMobile || (navigator.hardwareConcurrency && navigator.hardwareConcurrency <= 4) || (navigator.deviceMemory && navigator.deviceMemory < 4);
                
                if (isLowPerformance) {
                    document.body.classList.add('light-mode');
                    isLightMode = true;
                    console.log("Light mode enabled.");
                } else {
                    document.body.classList.remove('light-mode');
                    isLightMode = false;
                }
                return { isMobile, isLowPerformance };
            }

             // Get random prize based on weight
             function getRandomPrize() {
                let totalWeight = prizes.reduce((sum, prize) => sum + prize.weight, 0);
                const random = Math.random() * totalWeight;
                let weightSum = 0;
                for (const prize of prizes) {
                    weightSum += prize.weight;
                    if (random < weightSum) {
                        return prize;
                    }
                }
                return prizes[prizes.length - 1]; // Fallback
            }

            // Get appropriate translateZ based on media query
            function getFaceTranslateZ() {
                 return window.innerWidth <= 767 ? 100 : 140;
            }
             // Get appropriate machine dimensions
             function getMachineDimensions() {
                return window.innerWidth <= 767 ? { width: 240, height: 240 } : { width: 320, height: 320 };
            }

            // --- Core Logic Functions ---

            // Create octagon faces
            function createOctagon() {
                octagonContainer.innerHTML = ''; // Clear existing faces
                const numFaces = 8;
                const angleIncrement = 360 / numFaces;
                const translateZ = getFaceTranslateZ(); // Get dynamic value

                for (let i = 0; i < numFaces; i++) {
                    const face = document.createElement('div');
                    face.className = 'octagon-face';
                    // Set transform dynamically via JS
                    face.style.transform = `rotateY(${i * angleIncrement}deg) translateZ(${translateZ}px)`;
                    octagonContainer.appendChild(face);
                }
            }

            // Create lottery balls
            function createBalls(count) {
                balls = [];
                // Clear existing ball elements from the machine container
                const existingBalls = lotteryMachine.querySelectorAll('.ball');
                existingBalls.forEach(ball => ball.remove());
                
                const { width: machineWidth, height: machineHeight } = getMachineDimensions();
                const centerX = machineWidth / 2;
                const centerY = machineHeight / 2;


                for (let i = 0; i < count; i++) {
                    const ball = document.createElement('div');
                    ball.className = 'ball';
                    
                    const prize = getRandomPrize();
                    ball.textContent = prize.label;
                    ball.style.backgroundColor = prize.color;
                    ball.dataset.prize = prize.label;
                    
                    // Initial position calculation (more spread out)
                    const phi = Math.acos(2 * Math.random() - 1) - Math.PI / 2; // Latitude
                    const theta = Math.random() * Math.PI * 2; // Longitude
                    const radius = BALL_RADIUS + Math.random() * (getFaceTranslateZ() * 0.6); // Start within ~60% of radius
                    
                    // Center coordinates within the machine's local space
                    const x = centerX + radius * Math.cos(theta) * Math.cos(phi);
                    const y = centerY + radius * Math.sin(phi); // Y is vertical axis in this setup
                    const z = radius * Math.sin(theta) * Math.cos(phi); // Z is depth

                    // Apply initial transform
                    ball.style.transform = `translate3d(${x - BALL_RADIUS}px, ${y - BALL_RADIUS}px, ${z}px)`;

                    lotteryMachine.appendChild(ball); // Append to the machine itself
                    
                    balls.push({
                        element: ball,
                        x: x, y: y, z: z,
                        vx: 0, vy: 0, vz: 0, // Initial velocity
                        prize: prize,
                        radius: BALL_RADIUS
                    });
                }
                // console.log(`Created ${balls.length} balls.`);
            }

            // Update ball positions based on physics
            function updateBallPositions() {
                if (!balls.length) return;

                const maxRadius = getFaceTranslateZ() - BALL_RADIUS; // Max distance from center
                const maxRadiusSquared = maxRadius * maxRadius;
                const { width: machineWidth, height: machineHeight } = getMachineDimensions();
                const centerX = machineWidth / 2;
                const centerY = machineHeight / 2; // Y is vertical center
                const spinEffectFactor = currentSpinSpeed * 0.005; // Adjusted spin effect

                balls.forEach(ball => {
                    // 1. Apply Forces (Gravity, Spin)
                    ball.vy += GRAVITY; // Gravity pulls down along Y
                    // Centrifugal-like effect based on spin speed and Z position
                    const spinForceX = -spinEffectFactor * ball.z;
                    const spinForceZ = spinEffectFactor * (ball.x - centerX);
                    ball.vx += spinForceX;
                    ball.vz += spinForceZ;

                    // 2. Update Velocity (Apply friction)
                    ball.vx *= FRICTION;
                    ball.vy *= FRICTION;
                    ball.vz *= FRICTION;

                    // 3. Update Position
                    ball.x += ball.vx;
                    ball.y += ball.vy;
                    ball.z += ball.vz;

                    // 4. Boundary Collisions (Cylinder Approximation)
                    // Top/Bottom caps
                     if (ball.y < BALL_RADIUS) {
                        ball.y = BALL_RADIUS;
                        ball.vy *= -BOUNDARY_ELASTICITY;
                         if (soundEnabled && Math.abs(ball.vy) > 0.2 && Math.random() < 0.1) sounds.bounce.play();
                    } else if (ball.y > machineHeight - BALL_RADIUS) {
                        ball.y = machineHeight - BALL_RADIUS;
                        ball.vy *= -BOUNDARY_ELASTICITY;
                        if (soundEnabled && Math.abs(ball.vy) > 0.2 && Math.random() < 0.1) sounds.bounce.play();
                    }

                    // Side walls (radial distance)
                    const dx = ball.x - centerX;
                    const dz = ball.z;
                    const radialDistSq = dx * dx + dz * dz;

                    if (radialDistSq > maxRadiusSquared) {
                        const radialDist = Math.sqrt(radialDistSq);
                        // Normal vector (points from center to ball)
                        const nx = dx / radialDist;
                        const nz = dz / radialDist;

                        // Correct position
                        const correction = radialDist - maxRadius;
                        ball.x -= nx * correction;
                        ball.z -= nz * correction;

                        // Reflect velocity
                        const dotProduct = ball.vx * nx + ball.vz * nz;
                        ball.vx -= (1 + BOUNDARY_ELASTICITY) * dotProduct * nx;
                        ball.vz -= (1 + BOUNDARY_ELASTICITY) * dotProduct * nz;

                        if (soundEnabled && Math.sqrt(ball.vx*ball.vx + ball.vz*ball.vz) > 0.3 && Math.random() < 0.2) sounds.bounce.play();
                    }

                    // 5. Ball-Ball Collisions
                     for (let i = balls.indexOf(ball) + 1; i < balls.length; i++) {
                        const otherBall = balls[i];
                        const dx = otherBall.x - ball.x;
                        const dy = otherBall.y - ball.y;
                        const dz = otherBall.z - ball.z;
                        const distSq = dx * dx + dy * dy + dz * dz;
                        const minDist = ball.radius + otherBall.radius; // Sum of radii
                        const minDistSq = minDist * minDist;

                        if (distSq < minDistSq && distSq > 0.01) { // Check for collision and avoid self-collision
                            const distance = Math.sqrt(distSq);
                            // Collision normal (from ball to otherBall)
                            const nx = dx / distance;
                            const ny = dy / distance;
                            const nz = dz / distance;

                            // Separate balls slightly to avoid sticking
                            const overlap = minDist - distance;
                            const separationFactor = 0.51; // Slightly more than half
                            ball.x -= nx * overlap * separationFactor;
                            ball.y -= ny * overlap * separationFactor;
                            ball.z -= nz * overlap * separationFactor;
                            otherBall.x += nx * overlap * separationFactor;
                            otherBall.y += ny * overlap * separationFactor;
                            otherBall.z += nz * overlap * separationFactor;


                            // Relative velocity
                            const rvx = ball.vx - otherBall.vx;
                            const rvy = ball.vy - otherBall.vy;
                            const rvz = ball.vz - otherBall.vz;

                            // Velocity component along the normal
                            const velAlongNormal = rvx * nx + rvy * ny + rvz * nz;

                            // Do not resolve if velocities are separating
                            if (velAlongNormal > 0) continue;

                            // Calculate impulse scalar (simplified) - assuming equal mass
                            const impulse = -(1 + BALL_COLLISION_DAMPING) * velAlongNormal / 2; // Divided by 2 for two balls

                            // Apply impulse
                            ball.vx += impulse * nx;
                            ball.vy += impulse * ny;
                            ball.vz += impulse * nz;
                            otherBall.vx -= impulse * nx;
                            otherBall.vy -= impulse * ny;
                            otherBall.vz -= impulse * nz;

                            if (soundEnabled && Math.abs(velAlongNormal) > 0.3 && Math.random() < 0.15) sounds.bounce.play();
                        }
                    }


                    // 6. Update Element Style
                    // Scale based on Z for pseudo-perspective
                    const scale = 1 + (ball.z / (getFaceTranslateZ() * 2)); // Simple scaling
                    // Adjust position for transform origin (center)
                    const displayX = ball.x - ball.radius;
                    const displayY = ball.y - ball.radius;

                    ball.element.style.transform = `translate3d(${displayX}px, ${displayY}px, ${ball.z}px) scale(${scale})`;
                    ball.element.style.zIndex = Math.floor(centerY + ball.y); // Stacking order based on Y
                     // Opacity based on Z (further away = slightly dimmer)
                    const opacity = 0.8 + 0.2 * ((ball.z + maxRadius) / (2 * maxRadius));
                    ball.element.style.opacity = Math.max(0.5, Math.min(1, opacity));
                });
            }
            
            // Rotate the octagon container
            function rotateOctagon() {
                spinAngle += currentSpinSpeed;
                octagonContainer.style.transform = `rotateY(${spinAngle}deg)`;
            }

             // Main animation loop
            function animate(timestamp) {
                if (!isSpinning && currentSpinSpeed === 0 && handleAngle === 0) {
                    // No animation needed, stop the loop
                    animationFrameId = null;
                    return;
                }

                rotateOctagon();
                updateBallPositions();

                // Deceleration logic
                if (isSpinning && isDecelerating) {
                    currentSpinSpeed *= DECELERATION_FACTOR;
                    if (Math.abs(currentSpinSpeed) < MIN_SPIN_SPEED) {
                        stopSpinning(); // Trigger the stop sequence
                    }
                } else if (isSpinning && !isDecelerating) {
                     // Check if spin duration reached
                    if (timestamp - spinStartTime >= SPIN_DURATION_BEFORE_DECEL) {
                        isDecelerating = true; // Start decelerating
                    }
                }


                // Handle spring-back animation
                if (!isDragging && Math.abs(handleAngle) > 0.1) {
                    handleAngle *= 0.85; // Dampen the angle
                     handleVelocity *= 0.85; // Dampen velocity too
                    handle.style.transform = `rotate(${handleAngle}deg)`;
                } else if (!isDragging && handleAngle !== 0) {
                    // Snap back to 0 if angle is very small
                    handleAngle = 0;
                    handleVelocity = 0;
                    handle.style.transform = ''; // Reset transform
                }

                animationFrameId = requestAnimationFrame(animate); // Continue the loop
            }

            // Start the spinning process
            function startSpinning(initialSpeedBoost = 0) {
                if (isSpinning) return;
                
                isSpinning = true;
                isDecelerating = false; // Reset deceleration flag
                spinStartTime = performance.now(); // Record start time
                resultDisplay.textContent = '抽選中...';
                resultDisplay.classList.remove('winning');
                
                // Set base spin speed from selection
                const speedMap = { slow: 2, medium: 4, fast: 6 };
                currentSpinSpeed = speedMap[spinSpeedSelect.value] || 4;
                 // Add boost from handle drag, ensuring direction matches drag
                currentSpinSpeed += initialSpeedBoost;
                 // Ensure minimum speed if triggered by button
                 if (initialSpeedBoost === 0 && Math.abs(currentSpinSpeed) < 1) {
                    currentSpinSpeed = Math.sign(currentSpinSpeed || 1) * (speedMap[spinSpeedSelect.value] || 4);
                }


                // Play spin sound
                if (soundEnabled) {
                    sounds.spin.play();
                }
                
                // Show spotlight
                spotlight.style.opacity = '0.7'; // Use CSS transition
                
                // Add initial impulse to balls
                balls.forEach(ball => {
                    ball.vx += (Math.random() - 0.5) * 4; // Increased impulse
                    ball.vy += (Math.random() - 0.5) * 3 - 1; // Add slight upward/downward randomness
                    ball.vz += (Math.random() - 0.5) * 4;
                });
                
                // Disable controls
                startButton.disabled = true;
                resetButton.disabled = true;
                ballCountInput.disabled = true;
                spinSpeedSelect.disabled = true;

                // Start animation loop if not already running
                if (!animationFrameId) {
                    animationFrameId = requestAnimationFrame(animate);
                }
            }

            // Stop spinning and determine winner
            function stopSpinning() {
                isSpinning = false;
                currentSpinSpeed = 0; // Hard stop speed
                isDecelerating = false;
                 // Keep octagon at final angle
                octagonContainer.style.transform = `rotateY(${spinAngle}deg)`;

                // Stop spin sound
                if (soundEnabled) {
                    sounds.spin.stop();
                }
                
                // Hide spotlight
                spotlight.style.opacity = '0';
                
                // --- Winner Selection Logic ---
                // Select the ball that is "lowest" (highest Y value) and relatively central
                let potentialWinners = balls.filter(ball => ball.y > (getMachineDimensions().height * 0.6)); // Only consider balls in lower 40%
                if (potentialWinners.length === 0) potentialWinners = balls; // Fallback if no balls are low enough

                let winner = potentialWinners[0];
                let bestScore = -Infinity;

                 potentialWinners.forEach(ball => {
                     // Score based on how low (high y) and central (low radial distance) the ball is
                     const radialDistSq = (ball.x - getMachineDimensions().width / 2)**2 + (ball.z)**2;
                     const score = ball.y - Math.sqrt(radialDistSq) * 0.5; // Prioritize low Y, slightly penalize being far from center

                     if (score > bestScore) {
                         bestScore = score;
                         winner = ball;
                     }
                 });

                 if (!winner && balls.length > 0) {
                     winner = balls[Math.floor(Math.random() * balls.length)]; // Absolute fallback
                 } else if (!winner) {
                     console.error("No balls available to select a winner.");
                     resetLottery(); // Reset if something went wrong
                     return;
                 }


                // Animate the winning ball & show result
                if (winner) {
                    // console.log("Winner:", winner.prize.label, winner.element);
                    createParticleEffect(winner); // Create particles first

                    gsap.to(winner.element, {
                        duration: 0.4,
                        scale: 1.8, // Make it larger
                        boxShadow: `0 0 25px ${winner.prize.color}`,
                        ease: 'back.out(2)',
                        yoyo: true,
                        repeat: 3,
                        onComplete: () => {
                            showWinner(winner); // Show modal after animation
                            // Reset ball style after animation
                            gsap.to(winner.element, {
                                duration: 0.3,
                                scale: 1 + (winner.z / (getFaceTranslateZ() * 2)), // Return to normal scale
                                boxShadow: 'inset 0 0 8px rgba(0, 0, 0, 0.2), 0 0 4px rgba(0, 0, 0, 0.3)' // Return to normal shadow
                             });
                        }
                    });
                } else {
                     // Handle case where no winner could be determined (e.g., no balls)
                     resultDisplay.textContent = '抽選出錯';
                }

                // Re-enable controls
                startButton.disabled = false;
                resetButton.disabled = false;
                 ballCountInput.disabled = false;
                spinSpeedSelect.disabled = false;

                // Stop animation loop if handle is also still
                if(handleAngle === 0) {
                     cancelAnimationFrame(animationFrameId);
                     animationFrameId = null;
                 }
            }

            // Display the winning result modal
            function showWinner(winner) {
                if (!winner) return;

                if (soundEnabled) {
                    sounds.win.play();
                }
                
                winnerBall.style.backgroundColor = winner.prize.color;
                winnerBall.textContent = winner.prize.label;
                
                const messages = [
                    `恭喜！抽中了 ${winner.prize.label}！`,
                    `幸運降臨！是 ${winner.prize.label}！`,
                    `您的運勢是 ${winner.prize.label}！`,
                    `太棒了！得到 ${winner.prize.label}！`
                ];
                winnerMessage.textContent = messages[Math.floor(Math.random() * messages.length)];
                
                resultDisplay.textContent = `抽中: ${winner.prize.label}`;
                resultDisplay.classList.add('winning');
                
                winnerDisplay.classList.add('show');
                
                // Animate modal appearance using GSAP
                gsap.fromTo(winnerDisplay.querySelector('.winner-content'), 
                    { scale: 0.5, opacity: 0 },
                    { scale: 1, opacity: 1, duration: 0.5, ease: 'back.out(1.7)' }
                );
            }

            // Create particle explosion effect
            function createParticleEffect(winner) {
                if (isLightMode || !winner) return; // Skip in light mode or if no winner
                
                const particleCount = isLightMode ? 20 : 50; // Fewer particles in light mode? Or none?
                const colors = ['#FFD700', '#FFC107', '#FFA000', winner.prize.color, '#FFFFFF'];
                
                 // Get winner ball position relative to the viewport
                const ballRect = winner.element.getBoundingClientRect();
                const startX = ballRect.left + ballRect.width / 2;
                const startY = ballRect.top + ballRect.height / 2;

                for (let i = 0; i < particleCount; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'particle';
                    particle.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                    
                    // Set initial position at the center of the winner ball
                    particle.style.left = `${startX}px`;
                    particle.style.top = `${startY}px`;
                    
                    particlesContainer.appendChild(particle);
                    
                    // GSAP Animation for particle explosion
                    gsap.to(particle, {
                        x: (Math.random() - 0.5) * 300, // Spread horizontally
                        y: (Math.random() - 0.5) * 300, // Spread vertically
                        opacity: 1,
                        scale: Math.random() * 1.5 + 0.5, // Random size
                        duration: 0.6 + Math.random() * 0.4, // Random duration
                        ease: 'power3.out',
                        onComplete: () => {
                            // Fade out and remove
                            gsap.to(particle, {
                                opacity: 0,
                                duration: 0.3 + Math.random() * 0.3,
                                ease: 'power1.in',
                                onComplete: () => {
                                    particle.remove();
                                }
                            });
                        }
                    });
                }
            }

            // Reset the lottery machine state
            function resetLottery() {
                 // Stop ongoing animations/sounds immediately
                 isSpinning = false;
                 currentSpinSpeed = 0;
                 isDecelerating = false;
                 if (animationFrameId) {
                     cancelAnimationFrame(animationFrameId);
                     animationFrameId = null;
                 }
                 if (soundEnabled) sounds.spin.stop();
                 spotlight.style.opacity = '0';
                 gsap.killTweensOf('.ball'); // Stop any ongoing ball animations
                 gsap.killTweensOf('.winner-content'); // Stop modal animation

                // Reset UI
                resultDisplay.textContent = '準備重新抽選...';
                resultDisplay.classList.remove('winning');
                winnerDisplay.classList.remove('show');
                
                // Validate and get ball count
                let count = parseInt(ballCountInput.value, 10);
                count = Math.min(Math.max(count, 5), 30); // Clamp between 5 and 30
                ballCountInput.value = count; // Update input field if clamped
                
                createBalls(count); // Recreate balls
                spinAngle = 0; // Reset rotation angle
                octagonContainer.style.transform = `rotateY(0deg)`; // Reset visual rotation

                // Reset handle
                handleAngle = 0;
                handleVelocity = 0;
                handle.style.transform = '';

                // Enable controls
                startButton.disabled = false;
                resetButton.disabled = false;
                ballCountInput.disabled = false;
                spinSpeedSelect.disabled = false;

                // Short delay then update text
                setTimeout(() => {
                     if (!isSpinning) resultDisplay.textContent = '準備開始抽選...';
                 }, 500);
                 console.log("Lottery reset.");
            }

            // Handle drag events for the handle
            function handleDrag() {
                // --- Touch Events ---
                handleContainer.addEventListener('touchstart', (e) => {
                    if (isSpinning) return;
                    // e.preventDefault(); // Prevent scroll only if dragging starts
                    isDragging = true;
                    dragStartY = e.touches[0].clientY;
                    lastDragY = dragStartY;
                    handleVelocity = 0;
                    handleContainer.style.cursor = 'grabbing';
                    // Start animation loop if needed
                    if (!animationFrameId) animationFrameId = requestAnimationFrame(animate);
                }, { passive: false }); // Need passive:false to preventDefault inside

                document.addEventListener('touchmove', (e) => {
                    if (!isDragging) return;
                    e.preventDefault(); // Prevent scrolling while dragging handle
                    const currentY = e.touches[0].clientY;
                    const deltaY = currentY - lastDragY; // Change since last move
                    handleAngle += deltaY * 0.3; // Adjust sensitivity
                    handleAngle = Math.min(60, Math.max(-60, handleAngle)); // Clamp angle

                    // Update velocity (smoothed)
                    handleVelocity = handleVelocity * 0.8 + deltaY * 0.2;

                    handle.style.transform = `rotate(${handleAngle}deg)`;
                    lastDragY = currentY;
                }, { passive: false });

                document.addEventListener('touchend', (e) => {
                    if (!isDragging) return;
                    isDragging = false;
                    handleContainer.style.cursor = 'grab';

                    // Check velocity threshold to start spin
                    // console.log("Drag end velocity:", handleVelocity);
                    if (Math.abs(handleVelocity) > HANDLE_DRAG_THRESHOLD && !isSpinning) {
                         if (soundEnabled) sounds.click.play();
                         // Calculate speed boost based on velocity, preserving direction
                         const speedBoost = handleVelocity * 0.2 * (handleAngle > 0 ? -1 : 1) ; // Adjust multiplier as needed
                         startSpinning(speedBoost);
                    }
                    // Don't stop animation loop here, let spring-back happen in animate()
                });

                // --- Mouse Events ---
                handleContainer.addEventListener('mousedown', (e) => {
                     if (isSpinning) return;
                     e.preventDefault();
                     isDragging = true;
                     dragStartY = e.clientY;
                     lastDragY = dragStartY;
                     handleVelocity = 0;
                     handleContainer.style.cursor = 'grabbing';
                     // Start animation loop if needed
                     if (!animationFrameId) animationFrameId = requestAnimationFrame(animate);
                 });

                document.addEventListener('mousemove', (e) => {
                     if (!isDragging) return;
                     // No preventDefault needed for mousemove generally
                     const currentY = e.clientY;
                     const deltaY = currentY - lastDragY;
                     handleAngle += deltaY * 0.3;
                     handleAngle = Math.min(60, Math.max(-60, handleAngle));

                     handleVelocity = handleVelocity * 0.8 + deltaY * 0.2;

                     handle.style.transform = `rotate(${handleAngle}deg)`;
                     lastDragY = currentY;
                 });

                 // Add mouseup listener to the *document* to catch release outside the handle
                document.addEventListener('mouseup', (e) => {
                     if (!isDragging) return;
                     isDragging = false;
                     handleContainer.style.cursor = 'grab';

                     // console.log("Drag end velocity:", handleVelocity);
                     if (Math.abs(handleVelocity) > HANDLE_DRAG_THRESHOLD && !isSpinning) {
                         if (soundEnabled) sounds.click.play();
                          const speedBoost = handleVelocity * 0.2 * (handleAngle > 0 ? -1 : 1) ;
                         startSpinning(speedBoost);
                     }
                     // Don't stop animation loop here
                 });
            }

            // Toggle sound on/off
            function toggleSound() {
                soundEnabled = !soundEnabled;
                Howler.mute(!soundEnabled); // Mute all Howler sounds

                if (soundEnabled) {
                    soundStatus.textContent = "音效開啟";
                    soundToggle.querySelector('i').className = "fas fa-volume-up";
                } else {
                    soundStatus.textContent = "音效關閉";
                    soundToggle.querySelector('i').className = "fas fa-volume-mute";
                     // Ensure looping spin sound is stopped if muted during spin
                    sounds.spin.stop();
                }
                 if (soundEnabled) { // Play click sound on toggle ON
                    sounds.click.play();
                }
            }

            // Initialize the application
            function init() {
                 console.log("Initializing Lottery Machine...");
                const { isMobile } = checkDevicePerformance();
                
                createOctagon();
                
                let initialBallCount = parseInt(ballCountInput.value, 10);
                initialBallCount = Math.min(Math.max(initialBallCount, 5), 30);
                ballCountInput.value = initialBallCount;
                createBalls(initialBallCount);
                
                handleDrag();
                
                // Event Listeners
                startButton.addEventListener('click', () => {
                    if (!isSpinning) {
                         if (soundEnabled) sounds.click.play();
                         startSpinning(); // Start with default speed, no boost
                    }
                });
                
                resetButton.addEventListener('click', () => {
                     if (soundEnabled) sounds.click.play();
                     resetLottery();
                });
                
                soundToggle.addEventListener('click', toggleSound);
                
                closeWinner.addEventListener('click', () => {
                     winnerDisplay.classList.remove('show');
                     if (soundEnabled) sounds.click.play();
                });
                
                ballCountInput.addEventListener('change', () => {
                     // Validate on change and reset
                     let value = parseInt(ballCountInput.value, 10);
                     if (isNaN(value) || value < 5) value = 5;
                     if (value > 30) value = 30;
                     ballCountInput.value = value; // Update input field
                     resetLottery(); // Reset when count changes
                });

                 spinSpeedSelect.addEventListener('change', () => {
                     // Optional: Play click sound or give feedback
                     if (soundEnabled) sounds.click.play();
                     // Speed change will be read next time startSpinning is called
                 });

                 // Handle window resize to potentially update layout/physics params
                 window.addEventListener('resize', () => {
                     checkDevicePerformance(); // Re-check light mode
                     createOctagon(); // Re-create octagon with potentially new size
                     resetLottery(); // Reset balls based on new dimensions
                     console.log("Resized, reset lottery.");
                 });
                
                // Initial message update
                resultDisplay.textContent = '準備開始抽選...';
                console.log("Initialization complete.");
            }
            
            // --- Start Application ---
            init();
        });
    </script>
</body>
</html>