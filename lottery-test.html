<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>雅 (Miyabi) - 3D物理抽選機 (側視 - 完整版)</title>
    <!-- 引入字體 -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&family=Noto+Serif+JP:wght@400;700&display=swap" rel="stylesheet">
    <!-- 引入 FontAwesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">

    <!-- === 核心渲染與物理庫 === -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.0/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon-es/0.20.0/cannon-es.min.js"></script>

    <!-- === 動畫、交互與音效庫 === -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/Draggable.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.4/howler.min.js"></script>

    <!-- === 可選：調試工具 Importmap (如果需要 OrbitControls) === -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <!-- === 可選：調試工具 Module Script (如果需要 OrbitControls) === -->
    <!--
    <script type="module">
         import * as THREE from 'three';
         import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
         // Make OrbitControls globally accessible or pass it down
         window.OrbitControls = OrbitControls;
         // Ensure THREE is accessible if needed by other scripts or console
         window.THREE = THREE;
     </script>
     -->
     <!-- === 可選：調試工具 Cannon Debugger === -->
     <!-- <script src="https://unpkg.com/cannon-es-debugger@1.0.0/dist/cannon-es-debugger.js"></script> -->


    <style>
        /* === 基本樣式與顏色變數 === */
        :root {
            --primary: #B28046; /* 主色 - 棕金 */
            --primary-light: #D4AF6A; /* 亮金 */
            --primary-dark: #8C5E2A; /* 深木色 */
            --accent: #C0392b; /* 強調色 - 紅 */
            --background: #FDF6E3; /* 背景 - 米白 */
            --text: #4A3F35; /* 文字 - 深棕 */
            --glass: rgba(255, 255, 255, 0.2); /* 用於 Three.js 材質 */
            --gold-gradient: linear-gradient(135deg, #E4C57A 0%, #F8F4D8 50%, #E4C57A 100%);
            --wood-gradient: linear-gradient(135deg, #8B4513 0%, #A0522D 50%, #8B4513 100%);
            --shadow-color: rgba(0, 0, 0, 0.15);
            --highlight-color: rgba(255, 255, 255, 0.6);
            --ball-shadow: rgba(0, 0, 0, 0.3);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            height: 100%;
        }

        body {
            font-family: 'Noto Sans TC', sans-serif;
            background-color: var(--background);
            background-image:
                radial-gradient(circle at 100% 0%, rgba(178, 128, 70, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 0% 100%, rgba(192, 57, 43, 0.05) 0%, transparent 40%);
            color: var(--text);
            overflow-x: hidden; /* 防止水平滾動 */
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* 內容從頂部開始排列 */
            padding: 20px; /* Body 邊距 */
            -webkit-tap-highlight-color: transparent; /* 移除移動端點擊高亮 */
        }

        /* === 標題區域 === */
        .title-area {
            text-align: center;
            margin-bottom: 20px;
            position: relative;
            z-index: 10;
        }

        .title-area h1 {
            font-family: 'Noto Serif JP', serif;
            font-size: clamp(1.8rem, 5vw, 2.5rem);
            color: var(--primary-dark);
            margin-bottom: 15px;
            letter-spacing: 2px;
            position: relative;
            display: inline-block;
        }

        .title-area h1::after {
            content: '';
            position: absolute;
            bottom: -8px;
            left: 10%;
            width: 80%;
            height: 3px;
            background: var(--gold-gradient);
            border-radius: 2px;
        }

        .title-area p {
            font-size: clamp(0.9rem, 2.5vw, 1rem);
            color: var(--text);
            opacity: 0.8;
        }

        /* === Canvas 容器樣式 === */
        #canvas-container {
            width: 100%;
            max-width: 700px; /* Canvas 最大寬度 */
            aspect-ratio: 16 / 9; /* Canvas 縱橫比 */
            margin: 10px auto; /* 上下間距，左右居中 */
            position: relative;
            background-color: rgba(0, 0, 0, 0.03); /* 輕微背景色，區分區域 */
            border-radius: 10px;
            overflow: hidden; /* 確保 Canvas 不會溢出 */
            box-shadow: 0 5px 15px var(--shadow-color);
            z-index: 1; /* 確保在背景之上 */
        }

        canvas {
            display: block; /* 移除 Canvas 下方多餘空間 */
            width: 100%;
            height: 100%;
        }

        /* === 手把交互觸發區域 === */
        #handleDragTrigger {
            position: absolute;
            /* 定位在 Canvas 區域右側，或根據視覺效果調整 */
            bottom: 10%;
            /* 計算位置使其大致在 Canvas 右側外 (假設 Canvas 最大 700px 寬，居中) */
            right: calc(50% - min(350px, 45vw) - 40px - 10px); /* 50% - half_canvas_width - trigger_width/2 - spacing */
            width: 60px; /* 觸發區域寬度 */
            height: 150px; /* 觸發區域高度 */
            /* background: rgba(255, 0, 0, 0.1); */ /* 調試時取消註釋以查看區域 */
            z-index: 25; /* 確保在 Canvas 之上，但在彈窗之下 */
            cursor: grab;
             border-radius: 10px;
        }
        #handleDragTrigger:active { cursor: grabbing; }

        /* === 控制面板 === */
        .control-panel {
            position: relative; /* 相對定位 */
            width: 100%;
            max-width: 500px;
            margin: 25px auto 0; /* 與 Canvas 保持間距 */
            padding: 20px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
            text-align: center;
            border: 1px solid var(--primary-light);
            z-index: 20; /* 在 Canvas 之上 */
        }

        .result-display {
            font-size: clamp(1.2rem, 4vw, 1.5rem);
            font-weight: bold;
            margin: 15px 0;
            padding: 15px;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            background-color: var(--background);
            box-shadow: inset 0 1px 4px rgba(0, 0, 0, 0.1);
            color: var(--text);
            transition: all 0.3s ease;
        }
        .result-display.winning {
            background-color: var(--primary-light);
            color: var(--primary-dark);
            font-weight: 700;
            box-shadow: 0 0 15px var(--primary-light);
        }

        /* === 按鈕樣式 === */
        .button {
            background: var(--primary);
            color: white;
            border: none;
            padding: 10px 25px;
            font-size: 1rem;
            border-radius: 30px;
            cursor: pointer;
            margin: 8px;
            font-weight: 500;
            letter-spacing: 1px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            transition: all 0.2s ease-out;
            font-family: 'Noto Sans TC', sans-serif;
            position: relative;
            overflow: hidden;
            -webkit-tap-highlight-color: transparent;
        }
        .button::after { /* Ripple effect */
            content: '';
            position: absolute; top: 50%; left: 50%;
            width: 5px; height: 5px;
            background: rgba(255, 255, 255, 0.5);
            opacity: 0; border-radius: 100%;
            transform: scale(1, 1) translate(-50%);
            transform-origin: 50% 50%;
        }
        @keyframes ripple {
            0% { transform: scale(0, 0) translate(-50%); opacity: 1; }
            20% { transform: scale(25, 25) translate(-50%); opacity: 1; }
            100% { opacity: 0; transform: scale(40, 40) translate(-50%); }
        }
        .button:focus:not(:active)::after { animation: ripple 1s ease-out; }
        .button:hover {
            background: var(--primary-dark);
            transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
        }
        .button:active {
            transform: translateY(-1px);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.15);
        }
        .button.start { background: var(--accent); }
        .button.start:hover { background: #a5281e; }
        .button:disabled {
            background: #cccccc; cursor: not-allowed;
            transform: none; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        /* === 設定面板樣式 === */
        .settings-panel {
            margin-top: 20px; padding-top: 20px;
            border-top: 1px solid rgba(0, 0, 0, 0.1);
        }
        .settings-panel h3 {
            margin-bottom: 15px; font-size: 1.1rem;
            color: var(--text); font-weight: 500;
        }
        .settings-row {
            display: flex; justify-content: center; align-items: center;
            flex-wrap: wrap; gap: 15px 25px; margin-bottom: 15px;
        }
        .input-group { display: flex; align-items: center; }
        .input-group label { margin-right: 8px; font-size: 0.9rem; white-space: nowrap; }
        .input-group input, .input-group select {
            padding: 8px 12px; border-radius: 5px; border: 1px solid #ccc;
            font-family: inherit; min-width: 60px; background-color: white;
        }
        .input-group input[type="number"] { width: 70px; }

        /* === 音效控制樣式 === */
        .sound-controls { display: flex; justify-content: center; align-items: center; margin-top: 10px; }
        .sound-toggle {
            display: flex; align-items: center; cursor: pointer;
            padding: 5px 10px; border-radius: 20px;
            transition: background-color 0.2s ease; font-size: 0.9rem;
        }
        .sound-toggle:hover { background-color: rgba(0,0,0,0.05); }
        .sound-toggle i { margin-right: 8px; color: var(--primary); font-size: 1.1em; }

        /* === 粒子效果容器 === */
        .particles-container {
            position: fixed; /* 固定在視窗 */
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 100; overflow: hidden;
        }
        .particle {
            position: absolute; border-radius: 50%;
            opacity: 0; pointer-events: none;
            width: 8px; height: 8px;
        }
        .particle.confetti { width: 6px; height: 12px; border-radius: 0; }
        /* .particle.star::before { ... } */ /* Optional star shape */

        /* === 獎項顯示彈窗 === */
        .winner-display {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.75);
            display: flex; align-items: center; justify-content: center;
            z-index: 110; /* 最高層級 */
            opacity: 0; pointer-events: none;
            transition: opacity 0.4s ease-in-out; padding: 20px;
        }
        .winner-display.show { opacity: 1; pointer-events: auto; }
        .winner-content {
            background: linear-gradient(to bottom, #ffffff, #f8f8f0);
            padding: clamp(20px, 5vw, 40px); border-radius: 15px;
            text-align: center; max-width: 400px; width: 90%;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2), 0 0 0 5px rgba(255,255,255,0.3);
            transform: scale(0.7);
            transition: transform 0.4s cubic-bezier(0.68, -0.55, 0.27, 1.55);
            position: relative;
        }
        .winner-display.show .winner-content { transform: scale(1); }
        .winner-ball {
            width: clamp(80px, 20vw, 100px); height: clamp(80px, 20vw, 100px);
            border-radius: 50%; margin: 0 auto 25px;
            display: flex; align-items: center; justify-content: center;
            font-size: clamp(2rem, 8vw, 2.8rem); font-weight: bold; color: white;
            box-shadow: inset 0 -5px 10px rgba(0,0,0,0.3), 0 5px 15px rgba(0,0,0,0.3);
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            border: 3px solid rgba(255,255,255,0.5);
        }
        .winner-ball::before { /* Highlight */
            content: ''; position: absolute;
            top: 5%; left: 15%; width: 50%; height: 40%;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255,255,255,0.7) 0%, rgba(255,255,255,0) 70%);
            transform: rotate(-30deg);
        }
        .winner-title {
            font-size: clamp(1.5rem, 5vw, 1.8rem); color: var(--accent);
            margin-bottom: 15px; font-family: 'Noto Serif JP', serif; font-weight: 700;
        }
        .winner-message {
            font-size: clamp(1rem, 3.5vw, 1.2rem); margin-bottom: 25px; color: var(--text);
        }
        .close-button { /* Inherits .button styles */ }

        /* === 響應式設計 === */
        @media (max-width: 767px) {
            #canvas-container { max-width: 95%; aspect-ratio: 4 / 3; }
            #handleDragTrigger {
                width: 50px; height: 120px;
                bottom: 8%;
                right: 2%; /* 移到屏幕右側 */
            }
             .control-panel { margin-top: 20px; }
             .settings-row { gap: 10px 15px; }
        }
        @media (max-width: 480px) {
            .title-area h1 { font-size: 1.6rem; } .title-area p { font-size: 0.85rem; }
            .button { padding: 8px 20px; font-size: 0.9rem; margin: 5px; }
            #handleDragTrigger {
                width: 45px; height: 100px; bottom: 5%;
            }
            .control-panel { margin-top: 15px; padding: 15px; }
            .settings-panel h3 { font-size: 1rem; }
        }

        /* === 輕量模式樣式 (可選) === */
        body.light-mode #canvas-container {
             box-shadow: 0 3px 8px rgba(0,0,0,0.1); /* Lighter shadow */
        }
         body.light-mode {
             /* Reduce visual fidelity if needed */
         }

    </style>
</head>
<body>
    <!-- === HTML 結構 === -->
    <div class="title-area">
        <h1>雅 - 3D物理抽選機 (側視 - 完整版)</h1>
        <p>真實碰撞，幸運降臨</p>
    </div>

    <div id="canvas-container">
        <!-- Canvas will be inserted here by Three.js -->
    </div>

    <div id="handleDragTrigger"></div> <!-- 手把交互觸發區域 -->

    <div class="control-panel">
        <div class="result-display" id="resultDisplay">準備好了嗎？</div>
        <div>
            <button class="button start" id="startButton">開始抽選</button>
            <button class="button" id="resetButton">重置獎球</button>
        </div>
        <div class="settings-panel">
            <h3>抽選設定</h3>
            <div class="settings-row">
                <div class="input-group">
                    <label for="ballCount">球數量:</label>
                    <input type="number" id="ballCount" min="5" max="30" value="15"> <!-- 減少最大值 -->
                </div>
                <div class="input-group">
                    <label for="spinSpeed">轉速:</label>
                    <select id="spinSpeed">
                        <option value="0.8">慢</option>
                        <option value="1.0" selected>中</option>
                        <option value="1.3">快</option>
                    </select>
                </div>
                <div class="sound-controls">
                   <div class="sound-toggle" id="soundToggle">
                       <i class="fas fa-volume-up"></i> <span id="soundStatus">音效開啟</span>
                   </div>
               </div>
           </div>
           <!-- <div class="settings-row custom-balls-placeholder">(自訂球色功能開發中)</div> -->
        </div>
    </div>

    <div class="particles-container" id="particlesContainer"></div>

    <div class="winner-display" id="winnerDisplay">
        <div class="winner-content">
            <div class="winner-ball" id="winnerBall">?</div>
            <h2 class="winner-title">恭喜中獎！</h2>
            <p class="winner-message" id="winnerMessage">您抽中了幸運獎項！</p>
            <button class="button close-button" id="closeWinner">確認</button>
        </div>
    </div>

    <!-- === JavaScript === -->
    <script type="module">
        // Ensure THREE and CANNON are available globally if not using importmap strictly
        const THREE = window.THREE;
        const CANNON = window.CANNON;
        const gsap = window.gsap;
        const Draggable = window.Draggable;
        const Howl = window.Howl;
        const Howler = window.Howler;

        // Wrap in IIFE
        (async function() {
            // --- DOM References ---
            const canvasContainer = document.getElementById('canvas-container');
            const handleDragTrigger = document.getElementById('handleDragTrigger');
            const resultDisplay = document.getElementById('resultDisplay');
            const startButton = document.getElementById('startButton');
            const resetButton = document.getElementById('resetButton');
            const ballCountInput = document.getElementById('ballCount');
            const spinSpeedSelect = document.getElementById('spinSpeed');
            const soundToggle = document.getElementById('soundToggle');
            const soundStatus = document.getElementById('soundStatus');
            const particlesContainer = document.getElementById('particlesContainer');
            const winnerDisplay = document.getElementById('winnerDisplay');
            const winnerBall = document.getElementById('winnerBall');
            const winnerMessage = document.getElementById('winnerMessage');
            const closeWinner = document.getElementById('closeWinner');

            // --- Configuration ---
            const config = {
                machineRadius: 1.0, machineHeight: 1.5, ballRadius: 0.1,
                gravity: -9.82, physicsTimeStep: 1 / 60, numFaces: 8,
                handleSensitivity: 0.8, dragInertia: 0.90, minSpinVelocity: 1.5,
                baseSpinDuration: 3.5, spinRandomness: 1.5, maxSpinSpeedRad: 18,
                ejectionDuration: 1.5,
                prizes: [ { label: "大吉", color: "#E74C3C", weight: 1 }, { label: "中吉", color: "#E67E22", weight: 2 }, { label: "小吉", color: "#F1C40F", weight: 3 }, { label: "吉", color: "#2ECC71", weight: 5 }, { label: "末吉", color: "#3498DB", weight: 8 }, { label: "無念", color: "#95A5A6", weight: 10 } ],
                particleCount: 70,
                particleColors: ['#FFD700', '#FFC107', '#FF9800', '#FF69B4', '#FFFFFF']
            };

            // --- State Variables ---
            let isSpinning = false, soundEnabled = true, isLightMode = false;
            let balls = [];
            let spinTargetSpeed = 0, currentSpinSpeed = 0, spinDeceleration = 0.985;

            // --- Three.js Variables ---
            let scene, camera, renderer, ambientLight, directionalLight;
            let machineGroup, drumMesh, baseMesh, chuteMesh;
            let orbitControls; // For debugging

            // --- Cannon-es Variables ---
            let world, physicsMaterial, ballMaterial, wallMaterial;
            let drumBody;
            let cannonDebugger; // For debugging

            // --- Audio ---
            // !! REPLACE BASE64 WITH YOUR ACTUAL SOUNDS !!
            const sounds = {
                spin: new Howl({ src: ['data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQwAAAAAAACAAA=='], volume: 0.4, loop: true, rate: 1.0 }), // Placeholder Spin
                win: new Howl({ src: ['data:audio/wav;base64,UklGRiIAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAAAA=='], volume: 0.7 }), // Placeholder Win
                click: new Howl({ src: ['data:audio/wav;base64,UklGRigAAAAXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAAAA=='], volume: 0.6 }), // Placeholder Click
                bounce: new Howl({ src: ['data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQwAAAAAAACAAA=='], volume: 0.15, pool: 10}) // Placeholder Bounce
            };
            Howler.autoUnlock = true;

            // --- Initialization ---
            async function init() {
                isLightMode = window.innerWidth <= 767;
                if(isLightMode) document.body.classList.add('light-mode');

                if (!THREE || !CANNON || !gsap || !Draggable || !Howl) {
                    console.error("One or more libraries failed to load!");
                    resultDisplay.textContent = "錯誤：無法載入所需函式庫";
                    return; // Stop initialization if libs are missing
                }

                setupThree();
                setupCannon();
                // await setupDebuggers(); // Uncomment if using debuggers
                createMachineModel();
                resetLottery();
                setupEventListeners();
                animate();
                console.log("3D抽選機 初始化完成！");
            }

            // --- Three.js Setup ---
            function setupThree() {
                try {
                    scene = new THREE.Scene();
                    const bgColor = getComputedStyle(document.body).getPropertyValue('--background').trim();
                    scene.background = new THREE.Color(bgColor || 0xFDF6E3);
                    scene.fog = new THREE.Fog(scene.background, 6, 18);

                    const aspect = canvasContainer.clientWidth / canvasContainer.clientHeight;
                    camera = new THREE.PerspectiveCamera(50, aspect, 0.1, 100);
                    camera.position.set(config.machineRadius * 5.0, config.machineHeight * 0.7, 0);
                    camera.lookAt(0, 0, 0);
                    scene.add(camera);

                    renderer = new THREE.WebGLRenderer({ antialias: !isLightMode, alpha: true });
                    renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
                    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                    renderer.shadowMap.enabled = !isLightMode;
                    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                    canvasContainer.appendChild(renderer.domElement);

                    ambientLight = new THREE.AmbientLight(0xffffff, 0.9);
                    scene.add(ambientLight);

                    directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
                    directionalLight.position.set(4, 8, 6);
                    directionalLight.castShadow = !isLightMode;
                    if(!isLightMode) {
                        directionalLight.shadow.mapSize.width = 1024; directionalLight.shadow.mapSize.height = 1024;
                        directionalLight.shadow.camera.near = 1; directionalLight.shadow.camera.far = 20;
                        directionalLight.shadow.camera.left = -5; directionalLight.shadow.camera.right = 5;
                        directionalLight.shadow.camera.top = 5; directionalLight.shadow.camera.bottom = -5;
                        directionalLight.shadow.bias = -0.002;
                    }
                    scene.add(directionalLight);
                    scene.add(directionalLight.target);
                    directionalLight.target.position.set(0, 0, 0);

                    const hemiLight = new THREE.HemisphereLight(0xffffff, 0x888888, 0.5);
                    hemiLight.position.set(0, 10, 0);
                    scene.add(hemiLight);

                     console.log("Three.js setup complete.");

                } catch (error) {
                     console.error("Error during Three.js setup:", error);
                     resultDisplay.textContent = "錯誤：無法初始化 3D 場景";
                 }
            }

            // --- Cannon-es Setup ---
            function setupCannon() {
                 try {
                    world = new CANNON.World({ gravity: new CANNON.Vec3(0, config.gravity, 0) });
                    world.broadphase = new CANNON.SAPBroadphase(world);
                    world.allowSleep = true;

                    physicsMaterial = new CANNON.Material("physics");
                    ballMaterial = new CANNON.Material("ball");
                    wallMaterial = new CANNON.Material("wall");

                    world.addContactMaterial(new CANNON.ContactMaterial(ballMaterial, wallMaterial, { friction: 0.1, restitution: 0.5 }));
                    world.addContactMaterial(new CANNON.ContactMaterial(ballMaterial, ballMaterial, { friction: 0.2, restitution: 0.6 }));
                    world.addContactMaterial(new CANNON.ContactMaterial(wallMaterial, wallMaterial, { friction: 0.0, restitution: 0.1 }));

                     // Add bounce sound listener using simple collision check in step
                     // The material 'collide' event is less reliable in some versions/setups

                     console.log("Cannon-es setup complete.");

                } catch (error) {
                     console.error("Error during Cannon-es setup:", error);
                     resultDisplay.textContent = "錯誤：無法初始化物理引擎";
                 }
            }

            // --- Setup Debuggers (Optional) ---
            /*
            async function setupDebuggers() {
                 // Orbit Controls
                 if (window.OrbitControls) {
                    orbitControls = new window.OrbitControls(camera, renderer.domElement);
                    orbitControls.enableDamping = true; orbitControls.dampingFactor = 0.05;
                    orbitControls.screenSpacePanning = false; orbitControls.minDistance = 2; orbitControls.maxDistance = 15;
                    console.log("OrbitControls Enabled");
                } else { console.warn("OrbitControls not loaded/found."); }

                // Cannon Debugger
                if (window.CannonDebugger) {
                    cannonDebugger = new CannonDebugger(scene, world, { color: 0x00ff00 });
                    console.log("CannonDebugger Enabled");
                } else { console.warn("CannonDebugger not loaded/found."); }
            }
            */

            // --- Create 3D Models & Physics Bodies ---
            function createMachineModel() {
                 try {
                    machineGroup = new THREE.Group();
                    scene.add(machineGroup);

                    const radius = config.machineRadius; const sides = config.numFaces; const height = config.machineHeight;
                    const drumGeometry = new THREE.CylinderGeometry(radius, radius, height, sides, 1, false);
                    const drumMaterial = new THREE.MeshStandardMaterial({
                        color: 0xEAEAEA, // Slightly darker gray
                        transparent: true, opacity: 0.5, roughness: 0.2, metalness: 0.1, envMapIntensity: 0.5
                    });
                    drumMesh = new THREE.Mesh(drumGeometry, drumMaterial);
                    drumMesh.position.y = 0; drumMesh.castShadow = true; drumMesh.receiveShadow = true;
                    machineGroup.add(drumMesh);

                    drumBody = new CANNON.Body({ mass: 0, type: CANNON.Body.KINEMATIC, material: wallMaterial });
                    const drumShapePhysics = new CANNON.Cylinder(radius, radius, height, sides);
                    drumBody.addShape(drumShapePhysics); drumBody.position.set(0, 0, 0);
                    world.addBody(drumBody);

                    const baseMaterial = new THREE.MeshStandardMaterial({ map: createWoodTexture(), roughness: 0.7, metalness: 0.1 });
                    const baseGeometry = new THREE.CylinderGeometry(radius * 1.1, radius * 1.2, 0.4, 16);
                    baseMesh = new THREE.Mesh(baseGeometry, baseMaterial);
                    baseMesh.position.y = -height / 2 - 0.2; baseMesh.receiveShadow = true;
                    machineGroup.add(baseMesh);

                    const chuteMaterial = new THREE.MeshStandardMaterial({ color: 0x555555, roughness: 0.5 });
                    const chuteSize = config.ballRadius * 2.5;
                    const chuteGeometry = new THREE.BoxGeometry(chuteSize, 0.5, chuteSize * 0.8);
                    chuteMesh = new THREE.Mesh(chuteGeometry, chuteMaterial);
                    chuteMesh.position.set(0, baseMesh.position.y - 0.3, radius * 0.6);
                    machineGroup.add(chuteMesh);

                    const groundBody = new CANNON.Body({ type: CANNON.Body.STATIC, material: wallMaterial });
                    groundBody.addShape(new CANNON.Plane());
                    groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
                    groundBody.position.y = baseMesh.position.y - 0.5;
                    world.addBody(groundBody);

                     console.log("Machine model created.");

                } catch (error) {
                     console.error("Error creating machine model:", error);
                     resultDisplay.textContent = "錯誤：無法創建抽選機模型";
                 }
            }
            // --- Wood Texture Helper ---
            function createWoodTexture() {
                 const canvas = document.createElement('canvas'); canvas.width = 64; canvas.height = 128;
                 const context = canvas.getContext('2d'); context.fillStyle = '#A0522D'; context.fillRect(0, 0, 64, 128);
                 for (let i = 0; i < 100; i++) { context.fillStyle = `rgba(139, 69, 19, ${Math.random() * 0.3 + 0.1})`; context.fillRect(Math.random() * 64, Math.random() * 128, Math.random() * 2 + 0.5, Math.random() * 30 + 20); }
                 const texture = new THREE.CanvasTexture(canvas); texture.wrapS = THREE.RepeatWrapping; texture.wrapT = THREE.RepeatWrapping; texture.repeat.set(4, 2); return texture;
            }

            // --- Create Balls ---
            function createBalls(count) {
                try {
                    balls.forEach(ball => { if(ball.mesh) scene.remove(ball.mesh); if(ball.body) world.removeBody(ball.body); });
                    balls = [];

                    let weightedPrizes = [];
                    config.prizes.forEach(prize => { for (let i = 0; i < prize.weight; i++) weightedPrizes.push(prize); });

                    const ballGeometry = new THREE.SphereGeometry(config.ballRadius, 12, 8);
                    const ballShape = new CANNON.Sphere(config.ballRadius);
                    const textCanvas = document.createElement('canvas'); const textCtx = textCanvas.getContext('2d'); textCanvas.width = 64; textCanvas.height = 32;

                    for (let i = 0; i < count; i++) {
                        const prizeData = weightedPrizes[Math.floor(Math.random() * weightedPrizes.length)];
                        textCtx.fillStyle = prizeData.color; textCtx.fillRect(0, 0, 64, 32); textCtx.fillStyle = 'white'; textCtx.font = 'bold 14px Noto Sans TC'; textCtx.textAlign = 'center'; textCtx.textBaseline = 'middle'; textCtx.fillText(prizeData.label, 32, 16);
                        const ballTexture = new THREE.CanvasTexture(textCanvas); ballTexture.needsUpdate = true;

                        const ballMaterialInstance = new THREE.MeshStandardMaterial({ map: ballTexture, roughness: 0.4, metalness: 0.1 });
                        const ballMesh = new THREE.Mesh(ballGeometry, ballMaterialInstance);
                        ballMesh.castShadow = true; ballMesh.receiveShadow = true; ballMesh.userData.prize = prizeData;

                        const ballBody = new CANNON.Body({
                            mass: 0.1, shape: ballShape, material: ballMaterial,
                            position: new CANNON.Vec3( (Math.random() - 0.5) * config.machineRadius * 0.7, (Math.random() - 0.5) * (config.machineHeight * 0.8), (Math.random() - 0.5) * config.machineRadius * 0.7 ),
                            angularVelocity: new CANNON.Vec3((Math.random()-0.5)*8, (Math.random()-0.5)*8, (Math.random()-0.5)*8),
                            linearDamping: 0.1, angularDamping: 0.1, allowSleep: true, sleepSpeedLimit: 0.2, sleepTimeLimit: 0.5
                        });
                        ballBody.userData = { mesh: ballMesh }; // Link body to mesh for potential use

                        world.addBody(ballBody);
                        scene.add(ballMesh);
                        balls.push({ mesh: ballMesh, body: ballBody, prize: prizeData });
                    }
                    console.log(`創建了 ${balls.length} 個 3D 球`);

                } catch (error) {
                     console.error("Error creating balls:", error);
                     resultDisplay.textContent = "錯誤：無法創建球體";
                 }
            }

            // --- Animation Loop ---
            const clock = new THREE.Clock();
            function animate() {
                 requestAnimationFrame(animate); // Loop
                 const deltaTime = clock.getDelta();
                 const dt = config.physicsTimeStep; // Fixed step for physics

                 try {
                     // Spin Control Logic
                     if (isSpinning) {
                         currentSpinSpeed = THREE.MathUtils.lerp(currentSpinSpeed, spinTargetSpeed, 0.05);
                         if (spinTargetSpeed === 0 && Math.abs(currentSpinSpeed) > 0.05) {
                             currentSpinSpeed *= spinDeceleration;
                         } else if (spinTargetSpeed === 0 && Math.abs(currentSpinSpeed) <= 0.05) {
                             currentSpinSpeed = 0;
                             if (isSpinning) stopSpinning(); // Ensure stop is called only once
                         }
                     } else {
                         currentSpinSpeed = THREE.MathUtils.lerp(currentSpinSpeed, 0, 0.1);
                         if (Math.abs(currentSpinSpeed) < 0.01) currentSpinSpeed = 0;
                     }

                     // Update Kinematic Drum Body Rotation
                     if (drumBody && Math.abs(currentSpinSpeed) > 0) {
                         const currentQuat = drumBody.quaternion.clone();
                         const deltaQuat = new CANNON.Quaternion().setFromAxisAngle(new CANNON.Vec3(0, 1, 0), currentSpinSpeed * deltaTime);
                         // Use safe multiplication and copy back
                         const newQuat = deltaQuat.mult(currentQuat);
                         drumBody.quaternion.copy(newQuat);
                     }

                     // Step Physics World
                     world.step(dt);

                     // Update Visual Meshes from Physics Bodies
                     for (const ball of balls) {
                         if (ball.body && ball.mesh) { // Check if both exist
                             ball.mesh.position.copy(ball.body.position);
                             ball.mesh.quaternion.copy(ball.body.quaternion);
                         }
                     }
                     if (drumMesh && drumBody) {
                         drumMesh.quaternion.copy(drumBody.quaternion); // Sync visual drum rotation
                     }

                     // Update Debuggers/Controls if they exist
                     if (orbitControls) orbitControls.update();
                     if (cannonDebugger) cannonDebugger.update();

                     // Render Scene
                     renderer.render(scene, camera);

                } catch (error) {
                     console.error("Error during animation loop:", error);
                     // Consider stopping the loop or showing an error message
                     // For now, just log it to avoid infinite errors
                 }
            }

            // --- Event Listeners & Interaction ---
            function setupEventListeners() {
                 try {
                    startButton.addEventListener('click', handleSpinButtonClick);
                    resetButton.addEventListener('click', handleResetClick);
                    soundToggle.addEventListener('click', toggleSound);
                    closeWinner.addEventListener('click', hideWinnerDisplay);

                    Draggable.create(handleDragTrigger, {
                        type: "y", trigger: handleDragTrigger, inertia: true,
                        throwResistance: 4000, cursor: 'grab', activeCursor: 'grabbing',
                        onDragStart: function() { if (isSpinning) return; if (soundEnabled) sounds.click.play(); gsap.to(handleDragTrigger, { scale: 1.1, duration: 0.1 }); },
                        onDragEnd: function() {
                            gsap.to(handleDragTrigger, { scale: 1, duration: 0.3 });
                            gsap.to(this.target, { y: 0, duration: 0.5, ease: "power2.out" });
                            const finalVelocityY = this.getVelocity("y");
                            const angularVelFromDrag = -finalVelocityY * 0.015 * config.handleSensitivity;
                            if (Math.abs(angularVelFromDrag) > config.minSpinVelocity && !isSpinning) { startSpin(angularVelFromDrag, config.baseSpinDuration); }
                        }
                    });

                    window.addEventListener('resize', onWindowResize, false);
                     console.log("Event listeners set up.");
                } catch (error) {
                     console.error("Error setting up event listeners:", error);
                     resultDisplay.textContent = "錯誤：無法設定互動功能";
                 }
            }
            function onWindowResize() {
                 try {
                    const w = canvasContainer.clientWidth;
                    const h = canvasContainer.clientHeight;
                     if(w > 0 && h > 0) { // Ensure dimensions are valid
                        camera.aspect = w / h;
                        camera.updateProjectionMatrix();
                        renderer.setSize(w, h);
                    }
                 } catch(error) {
                      console.error("Error on window resize:", error);
                  }
            }

            // --- Spin Logic ---
            function startSpin(initialVelocityRad = 0, duration) {
                 if (isSpinning) return;
                 isSpinning = true; setControlsDisabled(true);
                 resultDisplay.textContent = '幸運轉動中...'; resultDisplay.classList.remove('winning');
                 if (soundEnabled) sounds.spin.play();
                 balls.forEach(b => b.body?.wakeUp()); // Use optional chaining

                 const speedFactor = parseFloat(spinSpeedSelect.value);
                 spinTargetSpeed = THREE.MathUtils.clamp( Math.abs(initialVelocityRad) + (config.maxSpinSpeedRad * 0.6 * speedFactor), config.minSpinVelocity * speedFactor, config.maxSpinSpeedRad * speedFactor ) * Math.sign(initialVelocityRad || -1);
                 currentSpinSpeed = initialVelocityRad;

                 const spinTime = (duration + Math.random() * config.spinRandomness) * 1000;
                 setTimeout(() => { if (isSpinning) spinTargetSpeed = 0; }, spinTime);

                 gsap.to('#canvas-container', { boxShadow: "inset 0 0 80px 40px rgba(255, 255, 200, 0.3)", duration: 0.5, yoyo: true, repeat: -1, repeatDelay: 0.1, ease:"power1.inOut" });
            }
            function stopSpinning() {
                 if (!isSpinning) return;
                 isSpinning = false; spinTargetSpeed = 0;
                 if (sounds.spin.playing()) sounds.spin.stop();
                 gsap.killTweensOf('#canvas-container');
                 gsap.to('#canvas-container', { boxShadow: "0 5px 15px var(--shadow-color)", duration: 0.5 });
                 setTimeout(determineWinner, 2000);
            }
            function determineWinner() {
                 if (isSpinning) return;
                 let winner = null; let lowestY = Infinity; let potentialWinners = [];
                 const holeCheckRadiusSq = (config.ballRadius * 1.5)**2; // Smaller radius for hole check
                 const holeCheckY = -config.machineHeight / 2 + config.ballRadius * 1.5; // Y threshold

                 balls.forEach(ball => {
                     if (!ball || !ball.body) return; // Check if ball and body exist
                     const pos = ball.body.position;
                     const distSq = pos.x * pos.x + pos.z * pos.z;
                     if (distSq < holeCheckRadiusSq && pos.y < holeCheckY) { potentialWinners.push(ball); }
                     if (pos.y < lowestY) { lowestY = pos.y; winner = ball; } // Fallback
                 });

                 if (potentialWinners.length > 0) {
                     winner = potentialWinners.reduce((lowest, current) => (current.body.position.y < lowest.body.position.y ? current : lowest), potentialWinners[0]);
                     console.log(`選中出口附近的球 (共 ${potentialWinners.length} 個)`);
                 } else { console.log("出口附近無球，選擇最低的球"); }

                 if (winner && winner.body) {
                     console.log(`中獎！獎品: ${winner.prize.label}`);
                     displayResult(winner); ejectBall(winner);
                 } else {
                     console.warn("未能選出有效的中獎球。");
                     // Attempt to find *any* remaining ball if the lowest somehow failed
                     const fallbackWinner = balls.find(b => b && b.body);
                     if (fallbackWinner) {
                         console.log(`備選中獎！獎品: ${fallbackWinner.prize.label}`);
                         displayResult(fallbackWinner); ejectBall(fallbackWinner);
                     } else {
                        resultDisplay.textContent = "抽選完成，無有效球";
                        setControlsDisabled(false);
                     }
                 }
            }

            // --- Display Result & Ejection ---
            function displayResult(winner) {
                resultDisplay.textContent = `恭喜！抽中 ${winner.prize.label}！`; resultDisplay.classList.add('winning');
                if (soundEnabled) sounds.win.play();
                triggerParticleEffect(winner.mesh); showWinnerDisplay(winner);
            }
            function ejectBall(winner) {
                if (!winner || !winner.body) return;
                console.log("彈出球:", winner.prize.label);
                const bodyToRemove = winner.body; winner.body = null; world.removeBody(bodyToRemove);

                const endPos = chuteMesh.position.clone(); endPos.y -= 0.3; endPos.z += config.ballRadius;
                const tl = gsap.timeline({
                    onComplete: () => {
                        console.log("球彈出動畫完成"); setControlsDisabled(false);
                        gsap.to(winner.mesh.scale, { x: 0.01, y: 0.01, z: 0.01, duration: 0.3, delay: 0.5, onComplete: () => { if(winner.mesh) scene.remove(winner.mesh); } });
                        balls = balls.filter(b => b !== winner);
                    }
                });
                const holePos = new CANNON.Vec3(0, -config.machineHeight / 2 - config.ballRadius * 1.5, 0);
                tl.to(winner.mesh.position, { x: holePos.x, y: holePos.y, z: holePos.z, duration: 0.4, ease: "power1.in" });
                tl.to(winner.mesh.position, { x: endPos.x, y: endPos.y, z: endPos.z, duration: 1.0, ease: "bounce.out" });
                gsap.to(winner.mesh.rotation, { x: `+=${Math.random()*6-3}`, y:`+=${Math.random()*6-3}`, z: `+=${Math.random()*6-3}`, duration: tl.duration(), ease: "none" });
            }

            // --- Helper Functions ---
            function setControlsDisabled(disabled) {
                startButton.disabled = disabled; resetButton.disabled = disabled;
                handleDragTrigger.style.pointerEvents = disabled ? 'none' : 'auto';
                handleDragTrigger.style.cursor = disabled ? 'not-allowed' : 'grab';
                const draggableInstance = Draggable.get(handleDragTrigger); // Get instance safely
                if(draggableInstance) draggableInstance[disabled ? 'disable' : 'enable']();
            }
            function toggleSound() {
                soundEnabled = !soundEnabled; soundStatus.textContent = soundEnabled ? "音效開啟" : "音效關閉";
                soundToggle.querySelector('i').className = soundEnabled ? "fas fa-volume-up" : "fas fa-volume-mute";
                Howler.mute(!soundEnabled); if (!soundEnabled && sounds.spin.playing()) sounds.spin.stop();
            }
            function triggerParticleEffect(targetMesh) {
                 if (isLightMode || !targetMesh) return;
                 const screenPos = toScreenPosition(targetMesh, camera, canvasContainer);
                 if (!screenPos) return;
                 for (let i = 0; i < config.particleCount; i++) {
                     const particle = document.createElement('div'); const isConfetti = Math.random() > 0.3;
                     particle.className = `particle ${isConfetti ? 'confetti' : ''}`; particle.style.backgroundColor = config.particleColors[Math.floor(Math.random() * config.particleColors.length)];
                     particlesContainer.appendChild(particle);
                     gsap.set(particle, { x: screenPos.x, y: screenPos.y, opacity: 1, scale: Math.random()*0.8+0.5, rotation: Math.random()*360 });
                     gsap.to(particle, { x: `+=${(Math.random()-0.5)*300}`, y: `+=${(Math.random()-0.5)*300}`, opacity: 0, scale: 0.1, rotation: `+=${Math.random()*720-360}`, duration: Math.random()*1.5+1, ease: "power2.out", delay: Math.random()*0.2, onComplete: () => particle.remove() });
                 }
            }
            function toScreenPosition(obj, camera, rendererContainer) {
                 if (!obj || !obj.matrixWorld || !camera || !rendererContainer) return null;
                 const vector = new THREE.Vector3();
                 try { obj.updateMatrixWorld(true); vector.setFromMatrixPosition(obj.matrixWorld); vector.project(camera); }
                 catch(e) { console.error("Error projecting object:", e); return null; }
                 const widthHalf = rendererContainer.clientWidth / 2; const heightHalf = rendererContainer.clientHeight / 2;
                 const x = (vector.x * widthHalf) + widthHalf; const y = -(vector.y * heightHalf) + heightHalf;
                 const rect = rendererContainer.getBoundingClientRect();
                 return { x: x + rect.left, y: y + rect.top };
            }
            function showWinnerDisplay(winner) {
                 if(!winner || !winner.prize) return;
                 winnerBall.style.backgroundColor = winner.prize.color; winnerBall.textContent = winner.prize.label;
                 winnerMessage.textContent = `恭喜您獲得 ${winner.prize.label}！願好運常伴！`; winnerDisplay.classList.add('show');
            }
            function hideWinnerDisplay() { winnerDisplay.classList.remove('show'); }

            // --- Reset ---
            function resetLottery() {
                try {
                    if (isSpinning) { isSpinning = false; spinTargetSpeed = 0; currentSpinSpeed = 0; if (sounds.spin.playing()) sounds.spin.stop(); gsap.killTweensOf('#canvas-container'); gsap.to('#canvas-container', { boxShadow: "0 5px 15px var(--shadow-color)", duration: 0.1 }); }
                    if (drumBody) { drumBody.quaternion.set(0, 0, 0, 1); drumBody.angularVelocity.set(0, 0, 0); }
                    if (drumMesh) { drumMesh.quaternion.set(0, 0, 0, 1); }
                    const ballCount = parseInt(ballCountInput.value, 10);
                    const validBallCount = Math.max(5, Math.min(30, isNaN(ballCount) ? 15 : ballCount));
                    ballCountInput.value = validBallCount; createBalls(validBallCount);
                    resultDisplay.textContent = "準備開始抽選"; resultDisplay.classList.remove('winning');
                    hideWinnerDisplay(); setControlsDisabled(false);
                     console.log("Lottery reset complete.");
                } catch(error) {
                    console.error("Error during resetLottery:", error);
                    resultDisplay.textContent = "錯誤：重置抽選機失敗";
                }
            }

            // --- Start Application ---
            init();

        })(); // End IIFE
    </script>

</body>
</html>