<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>雅 (Miyabi) - 3D物理抽選機 (側視)</title>
    <!-- 引入字體 -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&family=Noto+Serif+JP:wght@400;700&display=swap" rel="stylesheet">
    <!-- 引入 FontAwesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">

    <!-- === 核心渲染與物理庫 === -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.0/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon-es/0.20.0/cannon-es.min.js"></script>

    <!-- === 動畫、交互與音效庫 === -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/Draggable.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.4/howler.min.js"></script>
    <!-- === 可選：調試工具 === -->
    <!-- <script src="https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js"></script> -->
    <!-- <script src="https://unpkg.com/cannon-es-debugger@1.0.0/dist/cannon-es-debugger.js"></script> -->


    <style>
        /* === 基本樣式與顏色變數 === */
        :root {
            --primary: #B28046; /* 主色 - 棕金 */
            --primary-light: #D4AF6A; /* 亮金 */
            --primary-dark: #8C5E2A; /* 深木色 */
            --accent: #C0392b; /* 強調色 - 紅 */
            --background: #FDF6E3; /* 背景 - 米白 */
            --text: #4A3F35; /* 文字 - 深棕 */
            --glass: rgba(255, 255, 255, 0.2); /* 用於 Three.js 材質 */
            --gold-gradient: linear-gradient(135deg, #E4C57A 0%, #F8F4D8 50%, #E4C57A 100%);
            --wood-gradient: linear-gradient(135deg, #8B4513 0%, #A0522D 50%, #8B4513 100%);
            --shadow-color: rgba(0, 0, 0, 0.15);
            --highlight-color: rgba(255, 255, 255, 0.6);
            --ball-shadow: rgba(0, 0, 0, 0.3);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            height: 100%;
        }

        body {
            font-family: 'Noto Sans TC', sans-serif;
            background-color: var(--background);
            background-image:
                radial-gradient(circle at 100% 0%, rgba(178, 128, 70, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 0% 100%, rgba(192, 57, 43, 0.05) 0%, transparent 40%);
            color: var(--text);
            overflow-x: hidden; /* 防止水平滾動 */
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-start; /* 內容從頂部開始排列 */
            padding: 20px; /* Body 邊距 */
            -webkit-tap-highlight-color: transparent; /* 移除移動端點擊高亮 */
        }

        /* === 標題區域 (保持不變) === */
        .title-area {
            text-align: center;
            margin-bottom: 20px;
            position: relative;
            z-index: 10;
        }

        .title-area h1 {
            font-family: 'Noto Serif JP', serif;
            font-size: clamp(1.8rem, 5vw, 2.5rem);
            color: var(--primary-dark);
            margin-bottom: 15px;
            letter-spacing: 2px;
            position: relative;
            display: inline-block;
        }

        .title-area h1::after {
            content: '';
            position: absolute;
            bottom: -8px;
            left: 10%;
            width: 80%;
            height: 3px;
            background: var(--gold-gradient);
            border-radius: 2px;
        }

        .title-area p {
            font-size: clamp(0.9rem, 2.5vw, 1rem);
            color: var(--text);
            opacity: 0.8;
        }

        /* === Canvas 容器樣式 === */
        #canvas-container {
            width: 100%;
            max-width: 700px; /* Canvas 最大寬度 */
            aspect-ratio: 16 / 9; /* Canvas 縱橫比 */
            margin: 10px auto; /* 上下間距，左右居中 */
            position: relative;
            background-color: rgba(0, 0, 0, 0.03); /* 輕微背景色，區分區域 */
            border-radius: 10px;
            overflow: hidden; /* 確保 Canvas 不會溢出 */
            box-shadow: 0 5px 15px var(--shadow-color);
            z-index: 1; /* 確保在背景之上 */
        }

        canvas {
            display: block; /* 移除 Canvas 下方多餘空間 */
            width: 100%;
            height: 100%;
        }

        /* === 手把交互觸發區域 === */
        #handleDragTrigger {
            position: absolute;
            /* 定位在 Canvas 區域右側，或根據視覺效果調整 */
            bottom: 10%;
            right: calc(50% - min(350px, 45vw) - 40px); /* 大致在 Canvas 右側外 */
            width: 60px; /* 觸發區域寬度 */
            height: 150px; /* 觸發區域高度 */
            /* background: rgba(255, 0, 0, 0.2); */ /* 調試時取消註釋以查看區域 */
            z-index: 25; /* 確保在 Canvas 之上，但在彈窗之下 */
            cursor: grab;
             border-radius: 10px;
        }
        #handleDragTrigger:active { cursor: grabbing; }

        /* === 控制面板 (保持不變) === */
        .control-panel {
            position: relative; /* 相對定位 */
            width: 100%;
            max-width: 500px;
            margin: 25px auto 0; /* 與 Canvas 保持間距 */
            padding: 20px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
            text-align: center;
            border: 1px solid var(--primary-light);
            z-index: 20; /* 在 Canvas 之上 */
        }

        .result-display {
            font-size: clamp(1.2rem, 4vw, 1.5rem);
            font-weight: bold;
            margin: 15px 0;
            padding: 15px;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 8px;
            background-color: var(--background);
            box-shadow: inset 0 1px 4px rgba(0, 0, 0, 0.1);
            color: var(--text);
            transition: all 0.3s ease;
        }
        .result-display.winning {
            background-color: var(--primary-light);
            color: var(--primary-dark);
            font-weight: 700;
            box-shadow: 0 0 15px var(--primary-light);
        }

        /* === 按鈕樣式 (保持不變) === */
        .button {
            background: var(--primary);
            color: white;
            border: none;
            padding: 10px 25px;
            font-size: 1rem;
            border-radius: 30px;
            cursor: pointer;
            margin: 8px;
            font-weight: 500;
            letter-spacing: 1px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            transition: all 0.2s ease-out;
            font-family: 'Noto Sans TC', sans-serif;
            position: relative;
            overflow: hidden;
            -webkit-tap-highlight-color: transparent;
        }
        .button::after { /* Ripple effect */
            content: '';
            position: absolute; top: 50%; left: 50%;
            width: 5px; height: 5px;
            background: rgba(255, 255, 255, 0.5);
            opacity: 0; border-radius: 100%;
            transform: scale(1, 1) translate(-50%);
            transform-origin: 50% 50%;
        }
        @keyframes ripple {
            0% { transform: scale(0, 0) translate(-50%); opacity: 1; }
            20% { transform: scale(25, 25) translate(-50%); opacity: 1; }
            100% { opacity: 0; transform: scale(40, 40) translate(-50%); }
        }
        .button:focus:not(:active)::after { animation: ripple 1s ease-out; }
        .button:hover {
            background: var(--primary-dark);
            transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
        }
        .button:active {
            transform: translateY(-1px);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.15);
        }
        .button.start { background: var(--accent); }
        .button.start:hover { background: #a5281e; }
        .button:disabled {
            background: #cccccc; cursor: not-allowed;
            transform: none; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        /* === 設定面板樣式 (保持不變) === */
        .settings-panel {
            margin-top: 20px; padding-top: 20px;
            border-top: 1px solid rgba(0, 0, 0, 0.1);
        }
        .settings-panel h3 {
            margin-bottom: 15px; font-size: 1.1rem;
            color: var(--text); font-weight: 500;
        }
        .settings-row {
            display: flex; justify-content: center; align-items: center;
            flex-wrap: wrap; gap: 15px 25px; margin-bottom: 15px;
        }
        .input-group { display: flex; align-items: center; }
        .input-group label { margin-right: 8px; font-size: 0.9rem; white-space: nowrap; }
        .input-group input, .input-group select {
            padding: 8px 12px; border-radius: 5px; border: 1px solid #ccc;
            font-family: inherit; min-width: 60px; background-color: white;
        }
        .input-group input[type="number"] { width: 70px; }

        /* === 音效控制樣式 (保持不變) === */
        .sound-controls { display: flex; justify-content: center; align-items: center; margin-top: 10px; }
        .sound-toggle {
            display: flex; align-items: center; cursor: pointer;
            padding: 5px 10px; border-radius: 20px;
            transition: background-color 0.2s ease; font-size: 0.9rem;
        }
        .sound-toggle:hover { background-color: rgba(0,0,0,0.05); }
        .sound-toggle i { margin-right: 8px; color: var(--primary); font-size: 1.1em; }

        /* === 粒子效果容器 (保持不變) === */
        .particles-container {
            position: fixed; /* 固定在視窗 */
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 100; overflow: hidden;
        }
        .particle {
            position: absolute; border-radius: 50%;
            opacity: 0; pointer-events: none;
            width: 8px; height: 8px;
        }
        .particle.confetti { width: 6px; height: 12px; border-radius: 0; }
        /* .particle.star::before { ... } */ /* Optional star shape */

        /* === 獎項顯示彈窗 (保持不變) === */
        .winner-display {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.75);
            display: flex; align-items: center; justify-content: center;
            z-index: 110; /* 最高層級 */
            opacity: 0; pointer-events: none;
            transition: opacity 0.4s ease-in-out; padding: 20px;
        }
        .winner-display.show { opacity: 1; pointer-events: auto; }
        .winner-content {
            background: linear-gradient(to bottom, #ffffff, #f8f8f0);
            padding: clamp(20px, 5vw, 40px); border-radius: 15px;
            text-align: center; max-width: 400px; width: 90%;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2), 0 0 0 5px rgba(255,255,255,0.3);
            transform: scale(0.7);
            transition: transform 0.4s cubic-bezier(0.68, -0.55, 0.27, 1.55);
            position: relative;
        }
        .winner-display.show .winner-content { transform: scale(1); }
        .winner-ball {
            width: clamp(80px, 20vw, 100px); height: clamp(80px, 20vw, 100px);
            border-radius: 50%; margin: 0 auto 25px;
            display: flex; align-items: center; justify-content: center;
            font-size: clamp(2rem, 8vw, 2.8rem); font-weight: bold; color: white;
            box-shadow: inset 0 -5px 10px rgba(0,0,0,0.3), 0 5px 15px rgba(0,0,0,0.3);
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            border: 3px solid rgba(255,255,255,0.5);
        }
        .winner-ball::before { /* Highlight */
            content: ''; position: absolute;
            top: 5%; left: 15%; width: 50%; height: 40%;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255,255,255,0.7) 0%, rgba(255,255,255,0) 70%);
            transform: rotate(-30deg);
        }
        .winner-title {
            font-size: clamp(1.5rem, 5vw, 1.8rem); color: var(--accent);
            margin-bottom: 15px; font-family: 'Noto Serif JP', serif; font-weight: 700;
        }
        .winner-message {
            font-size: clamp(1rem, 3.5vw, 1.2rem); margin-bottom: 25px; color: var(--text);
        }
        .close-button { /* Inherits .button styles */ }

        /* === 響應式設計 (調整 Canvas 和觸發區域位置) === */
        @media (max-width: 767px) {
            #canvas-container { max-width: 95%; aspect-ratio: 4 / 3; }
            #handleDragTrigger {
                width: 50px; height: 120px;
                bottom: 8%;
                right: 2%; /* 移到屏幕右側 */
            }
             .control-panel { margin-top: 20px; }
             .settings-row { gap: 10px 15px; }
        }
        @media (max-width: 480px) {
            .title-area h1 { font-size: 1.6rem; }
            .title-area p { font-size: 0.85rem; }
            .button { padding: 8px 20px; font-size: 0.9rem; margin: 5px; }
             #handleDragTrigger {
                 width: 45px; height: 100px; bottom: 5%;
             }
             .control-panel { margin-top: 15px; padding: 15px; }
             .settings-panel h3 { font-size: 1rem; }
        }

        /* === 輕量模式樣式 (可選) === */
        body.light-mode #canvas-container {
            /* Maybe simpler background or no shadow */
        }
         body.light-mode /* ... potentially disable shadows in Three.js ... */

    </style>
</head>
<body>
    <!-- === HTML 結構 (保持不變) === -->
    <div class="title-area">
        <h1>雅 - 3D物理抽選機 (側視)</h1>
        <p>真實碰撞，幸運降臨</p>
    </div>

    <div id="canvas-container">
        <!-- Canvas will be inserted here by Three.js -->
    </div>

    <div id="handleDragTrigger"></div> <!-- 手把交互觸發區域 -->

    <div class="control-panel">
        <div class="result-display" id="resultDisplay">準備好了嗎？</div>
        <div>
            <button class="button start" id="startButton">開始抽選</button>
            <button class="button" id="resetButton">重置獎球</button>
        </div>
        <div class="settings-panel">
            <h3>抽選設定</h3>
            <div class="settings-row">
                <div class="input-group">
                    <label for="ballCount">球數量:</label>
                    <input type="number" id="ballCount" min="5" max="30" value="15"> <!-- 減少最大值 -->
                </div>
                <div class="input-group">
                    <label for="spinSpeed">轉速:</label>
                    <select id="spinSpeed">
                        <option value="0.8">慢</option>
                        <option value="1.0" selected>中</option>
                        <option value="1.3">快</option>
                    </select>
                </div>
                <div class="sound-controls">
                   <div class="sound-toggle" id="soundToggle">
                       <i class="fas fa-volume-up"></i> <span id="soundStatus">音效開啟</span>
                   </div>
               </div>
           </div>
           <!-- <div class="settings-row custom-balls-placeholder">(自訂球色功能開發中)</div> -->
        </div>
    </div>

    <div class="particles-container" id="particlesContainer"></div>
    <div class="winner-display" id="winnerDisplay">
        <div class="winner-content">
            <div class="winner-ball" id="winnerBall">?</div>
            <h2 class="winner-title">恭喜中獎！</h2>
            <p class="winner-message" id="winnerMessage">您抽中了幸運獎項！</p>
            <button class="button close-button" id="closeWinner">確認</button>
        </div>
    </div>

    <!-- === JavaScript (包含 Three.js, Cannon-es, GSAP 邏輯) === -->
    <script>
        // Wrap in IIFE to avoid polluting global scope
        (function() {
            // --- DOM References ---
            const canvasContainer = document.getElementById('canvas-container');
            const handleDragTrigger = document.getElementById('handleDragTrigger');
            const resultDisplay = document.getElementById('resultDisplay');
            const startButton = document.getElementById('startButton');
            const resetButton = document.getElementById('resetButton');
            const ballCountInput = document.getElementById('ballCount');
            const spinSpeedSelect = document.getElementById('spinSpeed');
            const soundToggle = document.getElementById('soundToggle');
            const soundStatus = document.getElementById('soundStatus');
            const particlesContainer = document.getElementById('particlesContainer');
            const winnerDisplay = document.getElementById('winnerDisplay');
            const winnerBall = document.getElementById('winnerBall');
            const winnerMessage = document.getElementById('winnerMessage');
            const closeWinner = document.getElementById('closeWinner');

            // --- Configuration ---
            const config = {
                machineRadius: 1.0, machineHeight: 1.5, ballRadius: 0.1,
                gravity: -9.82, physicsTimeStep: 1 / 60, numFaces: 8,
                handleSensitivity: 0.8, dragInertia: 0.90, minSpinVelocity: 1.5,
                baseSpinDuration: 3.5, spinRandomness: 1.5, maxSpinSpeedRad: 18,
                ejectionDuration: 1.5,
                prizes: [
                   { label: "大吉", color: "#E74C3C", weight: 1 }, { label: "中吉", color: "#E67E22", weight: 2 },
                   { label: "小吉", color: "#F1C40F", weight: 3 }, { label: "吉", color: "#2ECC71", weight: 5 },
                   { label: "末吉", color: "#3498DB", weight: 8 }, { label: "無念", color: "#95A5A6", weight: 10 }
                ],
                particleCount: 70,
                particleColors: ['#FFD700', '#FFC107', '#FF9800', '#FF69B4', '#FFFFFF']
            };

            // --- State Variables ---
            let isSpinning = false, soundEnabled = true, isLightMode = false;
            let balls = [];
            let spinTargetSpeed = 0, currentSpinSpeed = 0, spinDeceleration = 0.985;

            // --- Three.js Variables ---
            let scene, camera, renderer, ambientLight, directionalLight;
            let machineGroup, drumMesh, baseMesh, chuteMesh; // Added more mesh refs

            // --- Cannon-es Variables ---
            let world, physicsMaterial, ballMaterial, wallMaterial;
            let drumBody;

            // --- Audio ---
            // !! REPLACE BASE64 WITH YOUR ACTUAL SOUNDS !!
            const sounds = {
                spin: new Howl({ src: ['data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQwAAAAAAACAAA=='], volume: 0.4, loop: true, rate: 1.0 }), // Placeholder Spin
                win: new Howl({ src: ['data:audio/wav;base64,UklGRiIAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAAAA=='], volume: 0.7 }), // Placeholder Win
                click: new Howl({ src: ['data:audio/wav;base64,UklGRigAAAAXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAAAA=='], volume: 0.6 }), // Placeholder Click
                bounce: new Howl({ src: ['data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQwAAAAAAACAAA=='], volume: 0.15, pool: 10}) // Placeholder Bounce (pool for rapid playback)
            };
            Howler.autoUnlock = true;

            // --- Initialization ---
            function init() {
                isLightMode = window.innerWidth <= 767; // Simple light mode check
                if(isLightMode) document.body.classList.add('light-mode');

                setupThree();
                setupCannon();
                createMachineModel();
                resetLottery(); // Creates initial balls
                setupEventListeners();
                animate();
                console.log("3D抽選機 初始化完成！");
            }

            // --- Three.js Setup ---
            function setupThree() {
                scene = new THREE.Scene();
                scene.background = new THREE.Color(getComputedStyle(document.body).getPropertyValue('--background').trim()); // Use CSS var
                scene.fog = new THREE.Fog(scene.background, 5, 15); // Add subtle fog

                const aspect = canvasContainer.clientWidth / canvasContainer.clientHeight;
                camera = new THREE.PerspectiveCamera(50, aspect, 0.1, 100);
                camera.position.set(config.machineRadius * 4.0, config.machineHeight * 0.5, 0); // Adjusted side view
                camera.lookAt(0, 0, 0); // Look at origin
                scene.add(camera);

                renderer = new THREE.WebGLRenderer({ antialias: !isLightMode, alpha: true }); // Disable AA in light mode
                renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.shadowMap.enabled = !isLightMode; // Disable shadows in light mode
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                canvasContainer.appendChild(renderer.domElement);

                ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
                scene.add(ambientLight);

                directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
                directionalLight.position.set(3, 7, 5);
                directionalLight.castShadow = !isLightMode;
                if(!isLightMode) {
                    directionalLight.shadow.mapSize.width = 1024;
                    directionalLight.shadow.mapSize.height = 1024;
                    directionalLight.shadow.camera.near = 1;
                    directionalLight.shadow.camera.far = 20;
                    directionalLight.shadow.camera.left = -5;
                    directionalLight.shadow.camera.right = 5;
                    directionalLight.shadow.camera.top = 5;
                    directionalLight.shadow.camera.bottom = -5;
                     directionalLight.shadow.bias = -0.001; // Adjust shadow bias
                }
                scene.add(directionalLight);
                 scene.add(directionalLight.target); // Add target for lookAt control
                 directionalLight.target.position.set(0, 0, 0);
            }

            // --- Cannon-es Setup ---
            function setupCannon() {
                world = new CANNON.World({ gravity: new CANNON.Vec3(0, config.gravity, 0) });
                world.broadphase = new CANNON.SAPBroadphase(world); // More efficient broadphase
                world.allowSleep = true; // Allow bodies to sleep for performance

                physicsMaterial = new CANNON.Material("physics"); // Generic
                ballMaterial = new CANNON.Material("ball");
                wallMaterial = new CANNON.Material("wall");

                world.addContactMaterial(new CANNON.ContactMaterial(ballMaterial, wallMaterial, { friction: 0.1, restitution: 0.5 }));
                world.addContactMaterial(new CANNON.ContactMaterial(ballMaterial, ballMaterial, { friction: 0.2, restitution: 0.6 }));
                 world.addContactMaterial(new CANNON.ContactMaterial(wallMaterial, wallMaterial, { friction: 0.0, restitution: 0.1 })); // Walls shouldn't bounce much

                 // Add bounce sound listener
                 ballMaterial.addEventListener("collide", (event) => {
                    if(!isSpinning || !soundEnabled) return; // Only play during spin
                     const impactVelocity = event.contact.getImpactVelocityAlongNormal();
                     if (impactVelocity > 0.8) { // Only play for significant impacts
                         // Throttle sound playback
                         sounds.bounce.volume(Math.min(0.5, impactVelocity * 0.1));
                         sounds.bounce.rate(1.0 + Math.random() * 0.2); // Slight pitch variation
                         sounds.bounce.play();
                     }
                 });
            }

            // --- Create 3D Models & Physics Bodies ---
            function createMachineModel() {
                machineGroup = new THREE.Group();
                scene.add(machineGroup);

                // Drum Visual (Glass Octagon Cylinder)
                const drumShape = new THREE.Shape();
                const radius = config.machineRadius;
                const sides = config.numFaces;
                for (let i = 0; i <= sides; i++) {
                    const angle = (i / sides) * Math.PI * 2;
                    const x = radius * Math.cos(angle);
                    const z = radius * Math.sin(angle);
                    if (i === 0) drumShape.moveTo(x, z);
                    else drumShape.lineTo(x, z);
                }
                const extrudeSettings = { depth: config.machineHeight, bevelEnabled: false };
                const drumGeometry = new THREE.ExtrudeGeometry(drumShape, extrudeSettings);
                drumGeometry.center(); // Center the geometry
                drumGeometry.rotateX(Math.PI / 2); // Align height with Y axis

                const drumMaterial = new THREE.MeshPhysicalMaterial({ // Use PhysicalMaterial for better glass
                    color: 0xffffff,
                    transmission: 0.9, // Glass transmission
                    roughness: 0.05,
                    metalness: 0.0,
                    ior: 1.5, // Index of refraction for glass
                    thickness: 0.1, // Required for transmission
                    transparent: true,
                    opacity: 0.8, // Overall opacity
                    side: THREE.DoubleSide,
                    // envMap: scene.background, // Optional environment map
                });
                drumMesh = new THREE.Mesh(drumGeometry, drumMaterial);
                drumMesh.castShadow = true;
                drumMesh.receiveShadow = true;
                machineGroup.add(drumMesh);

                // Drum Physics (Kinematic Compound Shape)
                drumBody = new CANNON.Body({ mass: 0, type: CANNON.Body.KINEMATIC, material: wallMaterial });
                const angleStep = (Math.PI * 2) / sides;
                for (let i = 0; i < sides; i++) {
                    const angle = i * angleStep;
                    const planeShape = new CANNON.Plane();
                    const planeQuat = new CANNON.Quaternion().setFromAxisAngle(new CANNON.Vec3(0, 1, 0), angle - Math.PI / 2);
                    // Position the plane at the radius distance, slightly offset inward for safety
                    const planeOffset = new CANNON.Vec3(
                        (radius - 0.01) * Math.cos(angle), 0, (radius - 0.01) * Math.sin(angle)
                    );
                    drumBody.addShape(planeShape, planeOffset, planeQuat);
                }
                // Top Cap Plane
                drumBody.addShape(new CANNON.Plane(), new CANNON.Vec3(0, config.machineHeight / 2, 0), new CANNON.Quaternion().setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2));
                 // Bottom Cap Plane - WITH A HOLE (Use multiple planes around the hole)
                 const holeRadius = config.ballRadius * 2.5; // Size of the opening
                 const bottomY = -config.machineHeight / 2;
                 // Add 4 planes around the central hole
                 const bottomPlaneOffset = holeRadius;
                 const bottomPlaneSize = radius; // Make planes large enough
                 const bottomShape = new CANNON.Box(new CANNON.Vec3(bottomPlaneSize, 0.01, bottomPlaneSize)); // Thin box shape

                 // Simplified: One bottom plane with a central hole (not directly supported by Cannon, faking it)
                 // We will simply NOT add a bottom cap, letting balls fall through
                 // OR, add a temporary body that gets removed during ejection.
                 // Let's skip the bottom physics plane for ejection for now.

                world.addBody(drumBody);

                // Base Visual
                const baseMaterial = new THREE.MeshStandardMaterial({ map: createWoodTexture(), roughness: 0.7, metalness: 0.1 });
                const baseGeometry = new THREE.CylinderGeometry(radius * 1.1, radius * 1.2, 0.4, 16);
                baseMesh = new THREE.Mesh(baseGeometry, baseMaterial);
                baseMesh.position.y = -config.machineHeight / 2 - 0.2;
                baseMesh.receiveShadow = true;
                machineGroup.add(baseMesh);

                 // Chute Visual
                 const chuteMaterial = new THREE.MeshStandardMaterial({ color: 0x606060, roughness: 0.4 });
                 const chuteGeometry = new THREE.BoxGeometry(holeRadius * 1.8, 0.5, holeRadius * 1.2);
                 chuteMesh = new THREE.Mesh(chuteGeometry, chuteMaterial);
                 // Position under the conceptual hole (adjust Z for side view)
                 chuteMesh.position.set(0, baseMesh.position.y - 0.3, radius * 0.5); // Positioned towards the camera side slightly
                 machineGroup.add(chuteMesh);

                 // Static Ground Plane (Invisible physics plane)
                 const groundBody = new CANNON.Body({ mass: 0, material: wallMaterial });
                 groundBody.addShape(new CANNON.Plane());
                 groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2); // Rotate to be horizontal
                 groundBody.position.y = baseMesh.position.y - 0.5; // Below the base
                 world.addBody(groundBody);
            }
            // Helper to create a procedural wood texture
            function createWoodTexture() {
                 const canvas = document.createElement('canvas');
                 canvas.width = 256; canvas.height = 512;
                 const context = canvas.getContext('2d');
                 context.fillStyle = '#A0522D'; // Brown base
                 context.fillRect(0, 0, 256, 512);
                 for (let i = 0; i < 500; i++) { // Add darker lines for grain
                     context.fillStyle = `rgba(139, 69, 19, ${Math.random() * 0.3 + 0.1})`; // Darker brown
                     context.fillRect(Math.random() * 256, Math.random() * 512, Math.random() * 2 + 1, Math.random() * 100 + 50);
                 }
                 const texture = new THREE.CanvasTexture(canvas);
                 texture.wrapS = THREE.RepeatWrapping;
                 texture.wrapT = THREE.RepeatWrapping;
                 texture.repeat.set(2, 1);
                 return texture;
             }


            // --- Create Balls (3D Mesh + Physics Body) ---
            function createBalls(count) {
                balls.forEach(ball => { scene.remove(ball.mesh); world.removeBody(ball.body); });
                balls = [];

                let weightedPrizes = [];
                config.prizes.forEach(prize => { for (let i = 0; i < prize.weight; i++) weightedPrizes.push(prize); });

                const ballGeometry = new THREE.SphereGeometry(config.ballRadius, 16, 12);
                 const ballMeshes = []; // For instancing later if needed
                 const textCanvas = document.createElement('canvas');
                 const textCtx = textCanvas.getContext('2d');
                 textCanvas.width = 64; textCanvas.height = 32;

                 const ballShape = new CANNON.Sphere(config.ballRadius);

                for (let i = 0; i < count; i++) {
                    const prizeData = weightedPrizes[Math.floor(Math.random() * weightedPrizes.length)];

                     // Create Texture with Label
                     textCtx.fillStyle = prizeData.color;
                     textCtx.fillRect(0, 0, 64, 32);
                     textCtx.fillStyle = 'white';
                     textCtx.font = 'bold 16px Noto Sans TC';
                     textCtx.textAlign = 'center';
                     textCtx.textBaseline = 'middle';
                     textCtx.fillText(prizeData.label, 32, 16);
                     const ballTexture = new THREE.CanvasTexture(textCanvas);
                     ballTexture.needsUpdate = true;

                    const ballMaterialInstance = new THREE.MeshStandardMaterial({
                         map: ballTexture, // Use texture map
                         // color: prizeData.color, // Color is now in texture
                         roughness: 0.4, metalness: 0.1
                     });

                    const ballMesh = new THREE.Mesh(ballGeometry, ballMaterialInstance);
                    ballMesh.castShadow = true;
                    ballMesh.receiveShadow = true;
                     ballMesh.userData.prize = prizeData; // Store prize data

                    const ballBody = new CANNON.Body({
                        mass: 0.1, shape: ballShape, material: ballMaterial,
                        position: new CANNON.Vec3(
                            (Math.random() - 0.5) * config.machineRadius * 0.6,
                            (Math.random() * 0.5 + 0.1) * config.machineHeight, // Start higher up
                            (Math.random() - 0.5) * config.machineRadius * 0.6
                        ),
                        angularVelocity: new CANNON.Vec3((Math.random()-0.5)*8, (Math.random()-0.5)*8, (Math.random()-0.5)*8),
                        linearDamping: 0.1, angularDamping: 0.1, // Slightly more damping
                         allowSleep: true, sleepSpeedLimit: 0.2, sleepTimeLimit: 0.5 // Allow balls to sleep
                    });
                     ballBody.userData = { mesh: ballMesh }; // Link body back to mesh

                    world.addBody(ballBody);
                    scene.add(ballMesh);
                    balls.push({ mesh: ballMesh, body: ballBody, prize: prizeData });
                }
                console.log(`創建了 ${balls.length} 個 3D 球`);
            }

            // --- Animation Loop ---
            const clock = new THREE.Clock();
            let lastTime = 0;
            function animate(time) {
                requestAnimationFrame(animate);
                 // Use fixed timestep for physics if possible, or adaptive timestep
                 const deltaTime = clock.getDelta();
                 const physicsSteps = 5; // Increase physics steps per frame for stability
                 const dt = config.physicsTimeStep / physicsSteps;


                // Spin Control
                if (isSpinning) {
                    currentSpinSpeed = THREE.MathUtils.lerp(currentSpinSpeed, spinTargetSpeed, 0.05); // Slower lerp
                    if (spinTargetSpeed === 0 && Math.abs(currentSpinSpeed) > 0.05) {
                        currentSpinSpeed *= spinDeceleration;
                    } else if (spinTargetSpeed === 0 && Math.abs(currentSpinSpeed) <= 0.05) {
                        currentSpinSpeed = 0;
                        if (isSpinning) stopSpinning();
                    }
                } else {
                    currentSpinSpeed = THREE.MathUtils.lerp(currentSpinSpeed, 0, 0.1);
                    if (Math.abs(currentSpinSpeed) < 0.01) currentSpinSpeed = 0;
                }

                // Update Kinematic Drum Body
                if (drumBody && Math.abs(currentSpinSpeed) > 0) {
                     const currentQuat = drumBody.quaternion.clone(); // Clone to avoid issues
                     const deltaQuat = new CANNON.Quaternion().setFromAxisAngle(new CANNON.Vec3(0, 1, 0), currentSpinSpeed * deltaTime);
                     drumBody.quaternion.copy(deltaQuat.mult(currentQuat)); // Use copy for safety
                }

                 // Step the physics world multiple times for stability
                 for(let i = 0; i < physicsSteps; i++) {
                    world.step(dt);
                 }


                // Update visual meshes
                balls.forEach(ball => {
                    if (ball.body) { // Check if body exists (might be removed during ejection)
                        ball.mesh.position.copy(ball.body.position);
                        ball.mesh.quaternion.copy(ball.body.quaternion);
                         // Wake up bodies if they fall asleep unnaturally low?
                         // if(ball.body.sleepState === CANNON.Body.SLEEPING && ball.body.position.y > -config.machineHeight * 0.4) {
                         //    ball.body.wakeUp();
                         // }
                    }
                });
                if (drumMesh && drumBody) {
                    drumMesh.position.copy(drumBody.position);
                    drumMesh.quaternion.copy(drumBody.quaternion);
                }

                 // Update debuggers if enabled
                 // if (cannonDebugger) cannonDebugger.update();
                 // if (controls) controls.update();

                renderer.render(scene, camera);
                 lastTime = time;
            }

            // --- Event Listeners & Interaction ---
            function setupEventListeners() {
                 startButton.addEventListener('click', handleSpinButtonClick);
                 resetButton.addEventListener('click', handleResetClick);
                 soundToggle.addEventListener('click', toggleSound);
                 closeWinner.addEventListener('click', hideWinnerDisplay);

                 let dragStartY = 0;
                 let dragVelocityY = 0;

                 Draggable.create(handleDragTrigger, {
                     type: "y", trigger: handleDragTrigger, inertia: true,
                     throwResistance: 4000, cursor: 'grab', activeCursor: 'grabbing',
                     onDragStart: function() {
                         if (isSpinning) return;
                         dragStartY = this.y; dragVelocityY = 0;
                         if (soundEnabled) sounds.click.play();
                         gsap.to(handleDragTrigger, { scale: 1.1, duration: 0.1 });
                     },
                     onDrag: function() { dragVelocityY = this.getVelocity("y"); },
                     onThrowUpdate: function() { dragVelocityY = this.getVelocity("y"); },
                     onDragEnd: function() {
                         gsap.to(handleDragTrigger, { scale: 1, duration: 0.3 });
                         gsap.to(this.target, { y: 0, duration: 0.5, ease: "power2.out" }); // Snap trigger back visually

                         const finalVelocityY = this.getVelocity("y");
                         const angularVelFromDrag = -finalVelocityY * 0.015 * config.handleSensitivity; // Tune multiplier

                         if (Math.abs(angularVelFromDrag) > config.minSpinVelocity && !isSpinning) {
                             startSpin(angularVelFromDrag, config.baseSpinDuration);
                         }
                     }
                 });

                 window.addEventListener('resize', onWindowResize, false);
             }
             function onWindowResize() {
                 const w = canvasContainer.clientWidth;
                 const h = canvasContainer.clientHeight;
                 camera.aspect = w / h;
                 camera.updateProjectionMatrix();
                 renderer.setSize(w, h);
             }

            // --- Spin Logic ---
            function startSpin(initialVelocityRad = 0, duration) {
                 if (isSpinning) return;
                 isSpinning = true;
                 setControlsDisabled(true);
                 resultDisplay.textContent = '幸運轉動中...';
                 resultDisplay.classList.remove('winning');
                 if (soundEnabled) sounds.spin.play();

                 // Wake up all balls
                 balls.forEach(b => b.body.wakeUp());

                 const speedFactor = parseFloat(spinSpeedSelect.value);
                 spinTargetSpeed = THREE.MathUtils.clamp(
                     Math.abs(initialVelocityRad) + (config.maxSpinSpeedRad * 0.6 * speedFactor),
                     config.minSpinVelocity * speedFactor,
                     config.maxSpinSpeedRad * speedFactor
                 ) * Math.sign(initialVelocityRad || -1); // Default spin direction if no drag velocity

                 currentSpinSpeed = initialVelocityRad; // Start immediately with drag velocity

                 const spinTime = (duration + Math.random() * config.spinRandomness) * 1000;
                 setTimeout(() => { if (isSpinning) spinTargetSpeed = 0; }, spinTime);

                 // Fake spotlight effect
                 gsap.to('#canvas-container', {
                     boxShadow: "inset 0 0 80px 40px rgba(255, 255, 200, 0.3)",
                     duration: 0.5, yoyo: true, repeat: -1, repeatDelay: 0.1, ease:"power1.inOut"
                 });
            }
            function stopSpinning() {
                 if (!isSpinning) return;
                 isSpinning = false;
                 spinTargetSpeed = 0;
                 if (sounds.spin.playing()) sounds.spin.stop();

                 gsap.killTweensOf('#canvas-container');
                 gsap.to('#canvas-container', { boxShadow: "0 5px 15px var(--shadow-color)", duration: 0.5 });

                 setTimeout(determineWinner, 2000); // Longer wait for physics to settle
            }
            function determineWinner() {
                 if (isSpinning) return;
                 let winner = null;
                 let lowestY = Infinity;
                  let potentialWinners = [];

                 // Find all balls near the bottom center (conceptual hole)
                 balls.forEach(ball => {
                      if (!ball.body) return; // Skip if already ejected
                     const pos = ball.body.position;
                     const distSq = pos.x * pos.x + pos.z * pos.z; // Horizontal distance from center squared
                      // Check if near center and low enough
                     if (distSq < (config.ballRadius * 2)**2 && pos.y < (-config.machineHeight / 2 + config.ballRadius * 2)) {
                          potentialWinners.push(ball);
                     }
                      // Keep track of the absolute lowest ball as fallback
                      if (pos.y < lowestY) {
                         lowestY = pos.y;
                         winner = ball; // Fallback winner is the absolute lowest
                     }
                 });

                  // If balls are near the hole, pick the lowest among them
                 if (potentialWinners.length > 0) {
                     winner = potentialWinners.reduce((lowest, current) =>
                         (current.body.position.y < lowest.body.position.y ? current : lowest), potentialWinners[0]);
                     console.log(`選中出口附近的球 (共 ${potentialWinners.length} 個)`);
                 } else {
                     console.log("出口附近無球，選擇最低的球作為備選");
                 }


                 if (winner && winner.body) { // Ensure body still exists
                     console.log(`中獎！獎品: ${winner.prize.label}`);
                     displayResult(winner);
                     ejectBall(winner);
                 } else {
                     resultDisplay.textContent = "未能選出中獎球";
                     setControlsDisabled(false);
                 }
            }

            // --- Display Result & Ejection ---
            function displayResult(winner) {
                resultDisplay.textContent = `恭喜！抽中 ${winner.prize.label}！`;
                resultDisplay.classList.add('winning');
                if (soundEnabled) sounds.win.play();
                triggerParticleEffect(winner.mesh);
                showWinnerDisplay(winner);
            }
            function ejectBall(winner) {
                if (!winner || !winner.body) return; // Ensure ball and body exist
                console.log("彈出球:", winner.prize.label);

                const bodyToRemove = winner.body;
                winner.body = null; // Remove reference immediately
                world.removeBody(bodyToRemove);

                 // Calculate target position below the chute
                 const endPos = chuteMesh.position.clone();
                 endPos.y -= 0.5; // Below the chute visual

                const tl = gsap.timeline({
                    onComplete: () => {
                        console.log("球彈出動畫完成");
                        setControlsDisabled(false);
                         // Optionally hide the mesh completely after animation
                          gsap.to(winner.mesh.scale, { x: 0.01, y: 0.01, z: 0.01, duration: 0.3, delay: 0.5, onComplete: () => scene.remove(winner.mesh) });
                          // Remove the ball from the main array to prevent errors
                          balls = balls.filter(b => b !== winner);
                    }
                });

                 // Move smoothly towards the hole center first, then down through it
                 const holePos = new CANNON.Vec3(0, -config.machineHeight / 2 - config.ballRadius, 0);
                 tl.to(winner.mesh.position, {
                     x: holePos.x, y: holePos.y, z: holePos.z, // Move to hole center (slightly below bottom)
                     duration: 0.4, ease: "power1.in"
                 });
                 // Then drop to the final position with bounce
                 tl.to(winner.mesh.position, {
                     x: endPos.x, y: endPos.y, z: endPos.z,
                     duration: 1.0, ease: "bounce.out"
                 });

                 gsap.to(winner.mesh.rotation, {
                     x: `+=${Math.random() * 6 - 3}`, y:`+=${Math.random() * 6 - 3}`, z: `+=${Math.random() * 6 - 3}`,
                     duration: tl.duration(), ease: "none"
                 });
            }

            // --- Helper Functions ---
            function setControlsDisabled(disabled) {
                startButton.disabled = disabled; resetButton.disabled = disabled;
                handleDragTrigger.style.pointerEvents = disabled ? 'none' : 'auto';
                handleDragTrigger.style.cursor = disabled ? 'not-allowed' : 'grab';
                if (Draggable.get(handleDragTrigger)) Draggable.get(handleDragTrigger)[disabled ? 'disable' : 'enable']();
            }
            function toggleSound() {
                soundEnabled = !soundEnabled;
                soundStatus.textContent = soundEnabled ? "音效開啟" : "音效關閉";
                soundToggle.querySelector('i').className = soundEnabled ? "fas fa-volume-up" : "fas fa-volume-mute";
                Howler.mute(!soundEnabled);
                if (!soundEnabled && sounds.spin.playing()) sounds.spin.stop();
            }
             function triggerParticleEffect(targetMesh) {
                 if (isLightMode || !targetMesh) return;
                 const screenPos = toScreenPosition(targetMesh, camera, canvasContainer);
                 if (!screenPos) return; // Check if conversion failed

                 for (let i = 0; i < config.particleCount; i++) {
                     const particle = document.createElement('div');
                     const isConfetti = Math.random() > 0.3;
                     particle.className = `particle ${isConfetti ? 'confetti' : ''}`;
                     particle.style.backgroundColor = config.particleColors[Math.floor(Math.random() * config.particleColors.length)];
                     particlesContainer.appendChild(particle);

                     gsap.set(particle, { x: screenPos.x, y: screenPos.y, opacity: 1, scale: Math.random()*0.8+0.5, rotation: Math.random()*360 });
                     gsap.to(particle, {
                         x: `+=${(Math.random() - 0.5) * 300}`, y: `+=${(Math.random() - 0.5) * 300}`,
                         opacity: 0, scale: 0.1, rotation: `+=${Math.random()*720-360}`,
                         duration: Math.random()*1.5+1, ease: "power2.out", delay: Math.random()*0.2,
                         onComplete: () => particle.remove()
                     });
                 }
             }
             function toScreenPosition(obj, camera, rendererContainer) {
                if (!obj || !obj.matrixWorld) return null; // Basic check
                const vector = new THREE.Vector3();
                try {
                    obj.updateMatrixWorld(true); // Force update matrix world
                    vector.setFromMatrixPosition(obj.matrixWorld);
                    vector.project(camera); // Project to NDC
                } catch(e) {
                    console.error("Error projecting object:", e);
                    return null; // Return null if projection fails
                }

                 const widthHalf = rendererContainer.clientWidth / 2;
                 const heightHalf = rendererContainer.clientHeight / 2;
                 const x = (vector.x * widthHalf) + widthHalf;
                 const y = -(vector.y * heightHalf) + heightHalf;
                 const rect = rendererContainer.getBoundingClientRect();

                 // Return position relative to viewport, accounting for scroll
                 return { x: x + rect.left, y: y + rect.top };
             }
             function showWinnerDisplay(winner) {
                 winnerBall.style.backgroundColor = winner.prize.color;
                 winnerBall.textContent = winner.prize.label;
                 winnerMessage.textContent = `恭喜您獲得 ${winner.prize.label}！願好運常伴！`;
                 winnerDisplay.classList.add('show');
             }
             function hideWinnerDisplay() { winnerDisplay.classList.remove('show'); }

            // --- Reset ---
            function resetLottery() {
                if (isSpinning) { // Force stop if resetting mid-spin
                     isSpinning = false;
                     spinTargetSpeed = 0;
                     currentSpinSpeed = 0;
                     if (sounds.spin.playing()) sounds.spin.stop();
                     gsap.killTweensOf('#canvas-container');
                     gsap.to('#canvas-container', { boxShadow: "0 5px 15px var(--shadow-color)", duration: 0.1 });
                 }

                // Reset physics drum
                if (drumBody) { drumBody.quaternion.set(0, 0, 0, 1); drumBody.angularVelocity.set(0, 0, 0); }
                if (drumMesh) { drumMesh.quaternion.set(0, 0, 0, 1); }

                // Recreate balls
                const ballCount = parseInt(ballCountInput.value, 10);
                const validBallCount = Math.max(5, Math.min(30, isNaN(ballCount) ? 15 : ballCount));
                ballCountInput.value = validBallCount;
                createBalls(validBallCount);

                resultDisplay.textContent = "準備開始抽選";
                resultDisplay.classList.remove('winning');
                hideWinnerDisplay();
                setControlsDisabled(false);
            }

            // --- Start Application ---
            init();

        })(); // End IIFE
    </script>
</body>
</html>