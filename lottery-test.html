<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>雅 (Miyabi) - 日式3D物理抽選機 (修正版)</title>
    <!-- 引入字體 -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&family=Noto+Serif+JP:wght@400;700&display=swap" rel="stylesheet">
    <!-- 引入 FontAwesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">

    <!-- === 核心渲染與物理庫 === -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.0/three.min.js"></script>
    <!-- 使用 jsDelivr 作為 Cannon-es 的 CDN 來源 -->
    <script src="https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.min.js"></script>

    <!-- === 動畫、交互與音效庫 === -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/Draggable.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.4/howler.min.js"></script>

    <!-- === 可選：調試工具 Importmap === -->
    <!-- <script type="importmap">...</script> -->
    <!-- === 可選：調試工具 Module Script === -->
    <!-- <script type="module">...</script> -->
    <!-- === 可選：調試工具 Cannon Debugger === -->
    <!-- <script src="https://unpkg.com/cannon-es-debugger@1.0.0/dist/cannon-es-debugger.js"></script> -->


    <style>
        /* === 基本樣式與顏色變數 (保持不變) === */
        :root {
            --primary: #B28046; --primary-light: #D4AF6A; --primary-dark: #8C5E2A;
            --accent: #C0392b; --background: #FDF6E3; --text: #4A3F35;
            --glass-alpha: 0.6; /* Glass opacity */
            --gold: #D4AF37;
            --gold-gradient: linear-gradient(135deg, #E4C57A 0%, #F8F4D8 50%, #E4C57A 100%);
            --wood-gradient: linear-gradient(135deg, #8B4513 0%, #A0522D 50%, #8B4513 100%);
            --shadow-color: rgba(0, 0, 0, 0.15); --highlight-color: rgba(255, 255, 255, 0.6);
            --ball-shadow: rgba(0, 0, 0, 0.3);
        }
        /* --- 省略其他 CSS 規則，與上一版本相同 --- */
         * { margin: 0; padding: 0; box-sizing: border-box; } html { height: 100%; }
         body { font-family: 'Noto Sans TC', sans-serif; background-color: var(--background); background-image: radial-gradient(circle at 100% 0%, rgba(178, 128, 70, 0.1) 0%, transparent 50%), radial-gradient(circle at 0% 100%, rgba(192, 57, 43, 0.05) 0%, transparent 40%); color: var(--text); overflow-x: hidden; min-height: 100vh; display: flex; flex-direction: column; align-items: center; justify-content: flex-start; padding: 20px; -webkit-tap-highlight-color: transparent; }
        .title-area { text-align: center; margin-bottom: 15px; position: relative; z-index: 10; } /* Reduced bottom margin */
        .title-area h1 { font-family: 'Noto Serif JP', serif; font-size: clamp(1.6rem, 4vw, 2.2rem); color: var(--primary-dark); margin-bottom: 12px; letter-spacing: 2px; position: relative; display: inline-block; }
        .title-area h1::after { content: ''; position: absolute; bottom: -6px; left: 10%; width: 80%; height: 2px; background: var(--gold-gradient); border-radius: 1px; }
        .title-area p { font-size: clamp(0.85rem, 2vw, 0.95rem); color: var(--text); opacity: 0.8; }
        #canvas-container { width: 100%; max-width: 650px; aspect-ratio: 16 / 10; margin: 5px auto; position: relative; background-color: rgba(0, 0, 0, 0.02); border-radius: 10px; overflow: hidden; box-shadow: 0 4px 12px var(--shadow-color); z-index: 1; }
        canvas { display: block; width: 100%; height: 100%; }
        #handleDragTrigger { position: absolute; bottom: 12%; right: calc(50% - min(325px, 45vw) - 35px - 5px); width: 50px; height: 130px; z-index: 25; cursor: grab; border-radius: 8px; /* background: rgba(0, 255, 0, 0.1); */}
        #handleDragTrigger:active { cursor: grabbing; }
        .control-panel { position: relative; width: 100%; max-width: 480px; margin: 20px auto 0; padding: 18px; background: rgba(255, 255, 255, 0.97); border-radius: 12px; box-shadow: 0 6px 20px rgba(0, 0, 0, 0.08); text-align: center; border: 1px solid var(--primary-light); z-index: 20; }
        .result-display { font-size: clamp(1.1rem, 3.5vw, 1.4rem); font-weight: bold; margin: 12px 0; padding: 12px; min-height: 55px; display: flex; align-items: center; justify-content: center; border-radius: 6px; background-color: var(--background); box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.08); color: var(--text); transition: all 0.3s ease; }
        .result-display.winning { background-color: var(--primary-light); color: var(--primary-dark); font-weight: 700; box-shadow: 0 0 12px var(--primary-light); }
        .button { background: var(--primary); color: white; border: none; padding: 9px 22px; font-size: 0.95rem; border-radius: 30px; cursor: pointer; margin: 6px; font-weight: 500; letter-spacing: 0.5px; box-shadow: 0 3px 6px rgba(0, 0, 0, 0.1); transition: all 0.2s ease-out; font-family: 'Noto Sans TC', sans-serif; position: relative; overflow: hidden; -webkit-tap-highlight-color: transparent; }
        .button::after { content: ''; position: absolute; top: 50%; left: 50%; width: 5px; height: 5px; background: rgba(255, 255, 255, 0.5); opacity: 0; border-radius: 100%; transform: scale(1, 1) translate(-50%); transform-origin: 50% 50%; }
        @keyframes ripple { 0% { transform: scale(0, 0) translate(-50%); opacity: 1; } 20% { transform: scale(25, 25) translate(-50%); opacity: 1; } 100% { opacity: 0; transform: scale(40, 40) translate(-50%); } }
        .button:focus:not(:active)::after { animation: ripple 1s ease-out; }
        .button:hover { background: var(--primary-dark); transform: translateY(-2px); box-shadow: 0 5px 10px rgba(0, 0, 0, 0.12); }
        .button:active { transform: translateY(0px); box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); }
        .button.start { background: var(--accent); } .button.start:hover { background: #a5281e; }
        .button:disabled { background: #cccccc; cursor: not-allowed; transform: none; box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1); }
        .settings-panel { margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(0, 0, 0, 0.08); }
        .settings-panel h3 { margin-bottom: 12px; font-size: 1.05rem; color: var(--text); font-weight: 500; }
        .settings-row { display: flex; justify-content: center; align-items: center; flex-wrap: wrap; gap: 12px 20px; margin-bottom: 12px; }
        .input-group { display: flex; align-items: center; }
        .input-group label { margin-right: 6px; font-size: 0.85rem; white-space: nowrap; }
        .input-group input, .input-group select { padding: 7px 10px; border-radius: 4px; border: 1px solid #ccc; font-family: inherit; min-width: 55px; background-color: white; font-size: 0.9rem;}
        .input-group input[type="number"] { width: 65px; }
        .sound-controls { display: flex; justify-content: center; align-items: center; margin-top: 8px; }
        .sound-toggle { display: flex; align-items: center; cursor: pointer; padding: 4px 8px; border-radius: 20px; transition: background-color 0.2s ease; font-size: 0.85rem; }
        .sound-toggle:hover { background-color: rgba(0,0,0,0.05); }
        .sound-toggle i { margin-right: 6px; color: var(--primary); font-size: 1em; }
        .particles-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 100; overflow: hidden; }
        .particle { position: absolute; border-radius: 50%; opacity: 0; pointer-events: none; width: 8px; height: 8px; }
        .particle.confetti { width: 6px; height: 12px; border-radius: 0; }
        .winner-display { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.75); display: flex; align-items: center; justify-content: center; z-index: 110; opacity: 0; pointer-events: none; transition: opacity 0.4s ease-in-out; padding: 20px; }
        .winner-display.show { opacity: 1; pointer-events: auto; }
        .winner-content { background: linear-gradient(to bottom, #ffffff, #f8f8f0); padding: clamp(20px, 5vw, 35px); border-radius: 15px; text-align: center; max-width: 380px; width: 90%; box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2), 0 0 0 5px rgba(255,255,255,0.3); transform: scale(0.7); transition: transform 0.4s cubic-bezier(0.68, -0.55, 0.27, 1.55); position: relative; }
        .winner-display.show .winner-content { transform: scale(1); }
        .winner-ball { width: clamp(70px, 18vw, 90px); height: clamp(70px, 18vw, 90px); border-radius: 50%; margin: 0 auto 20px; display: flex; align-items: center; justify-content: center; font-size: clamp(1.8rem, 7vw, 2.5rem); font-weight: bold; color: white; box-shadow: inset 0 -4px 8px rgba(0,0,0,0.3), 0 4px 12px rgba(0,0,0,0.3); text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.5); border: 2px solid rgba(255,255,255,0.5); }
        .winner-ball::before { content: ''; position: absolute; top: 5%; left: 15%; width: 50%; height: 40%; border-radius: 50%; background: radial-gradient(circle, rgba(255,255,255,0.6) 0%, rgba(255,255,255,0) 70%); transform: rotate(-30deg); }
        .winner-title { font-size: clamp(1.4rem, 4.5vw, 1.7rem); color: var(--accent); margin-bottom: 12px; font-family: 'Noto Serif JP', serif; font-weight: 700; }
        .winner-message { font-size: clamp(0.95rem, 3vw, 1.1rem); margin-bottom: 20px; color: var(--text); }
        .close-button { padding: 8px 20px; font-size: 0.9rem; }
        @media (max-width: 767px) { #canvas-container { max-width: 95%; aspect-ratio: 4 / 3; } #handleDragTrigger { width: 50px; height: 120px; bottom: 8%; right: 2%; } .control-panel { margin-top: 20px; } .settings-row { gap: 10px 15px; } }
        @media (max-width: 480px) { .title-area h1 { font-size: 1.5rem; } .title-area p { font-size: 0.8rem; } .button { padding: 7px 18px; font-size: 0.85rem; margin: 5px; } #handleDragTrigger { width: 40px; height: 100px; bottom: 5%; } .control-panel { margin-top: 15px; padding: 15px; } .settings-panel h3 { font-size: 1rem; } .input-group label { font-size: 0.8rem; } .input-group input, .input-group select { padding: 6px 8px; font-size: 0.85rem;} }
        body.light-mode #canvas-container { box-shadow: 0 3px 8px rgba(0,0,0,0.1); }
        /* Add loading indicator style */
        #loadingIndicator { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: var(--primary-dark); font-size: 1.1rem; z-index: 5; display: none; /* Initially hidden */ }
        #canvas-container.loading #loadingIndicator { display: block; }
        #canvas-container.loading canvas { opacity: 0.5; } /* Optional: dim canvas while loading */
    </style>
</head>
<body>
    <!-- === HTML Structure === -->
    <div class="title-area">
        <h1>雅 - 日式3D物理抽選機</h1>
        <p>轉動幸運，結下良緣</p>
    </div>

    <div id="canvas-container">
        <div id="loadingIndicator">載入中...</div>
        <!-- Canvas will be inserted here -->
    </div>

    <div id="handleDragTrigger"></div>

    <div class="control-panel">
        <div class="result-display" id="resultDisplay">載入模型與物理引擎...</div>
        <div><button class="button start" id="startButton" disabled>開始抽選</button><button class="button" id="resetButton" disabled>重置獎球</button></div>
        <div class="settings-panel">
            <h3>抽選設定</h3>
            <div class="settings-row">
                <div class="input-group"><label for="ballCount">球數量:</label><input type="number" id="ballCount" min="5" max="30" value="15"></div>
                <div class="input-group"><label for="spinSpeed">轉速:</label><select id="spinSpeed"><option value="0.8">慢</option><option value="1.0" selected>中</option><option value="1.3">快</option></select></div>
                <div class="sound-controls"><div class="sound-toggle" id="soundToggle"><i class="fas fa-volume-up"></i> <span id="soundStatus">音效開啟</span></div></div>
            </div>
        </div>
    </div>

    <div class="particles-container" id="particlesContainer"></div>
    <div class="winner-display" id="winnerDisplay">
        <div class="winner-content">
            <div class="winner-ball" id="winnerBall">?</div><h2 class="winner-title">恭喜中獎！</h2>
            <p class="winner-message" id="winnerMessage">您抽中了幸運獎項！</p><button class="button close-button" id="closeWinner">確認</button>
        </div>
    </div>

    <!-- === JavaScript === -->
    <script> // Use standard script tag
        // Make libraries globally accessible
        const THREE = window.THREE;
        const CANNON = window.CANNON;
        const gsap = window.gsap;
        const Draggable = window.Draggable;
        const Howl = window.Howl;
        const Howler = window.Howler;

        (function() {
            // --- DOM References ---
            const canvasContainer = document.getElementById('canvas-container');
            const loadingIndicator = document.getElementById('loadingIndicator');
            const handleDragTrigger = document.getElementById('handleDragTrigger');
            const resultDisplay = document.getElementById('resultDisplay');
            const startButton = document.getElementById('startButton');
            const resetButton = document.getElementById('resetButton');
            const ballCountInput = document.getElementById('ballCount');
            const spinSpeedSelect = document.getElementById('spinSpeed');
            const soundToggle = document.getElementById('soundToggle');
            const soundStatus = document.getElementById('soundStatus');
            const particlesContainer = document.getElementById('particlesContainer');
            const winnerDisplay = document.getElementById('winnerDisplay');
            const winnerBall = document.getElementById('winnerBall');
            const winnerMessage = document.getElementById('winnerMessage');
            const closeWinner = document.getElementById('closeWinner');

            // --- Configuration ---
            const config = {
                machineRadius: 1.0, machineHeight: 1.6, // Slightly taller drum
                ballRadius: 0.09, // Slightly smaller balls
                gravity: -9.82, physicsTimeStep: 1 / 60, numFaces: 8, // Octagon
                handleSensitivity: 0.9, dragInertia: 0.92, minSpinVelocity: 1.8, // Adjusted sensitivity/velocity
                baseSpinDuration: 3.8, spinRandomness: 1.8, maxSpinSpeedRad: 20, // Adjusted spin speeds
                ejectionDuration: 1.5,
                prizes: [ { label: "大吉", color: "#E74C3C", weight: 1 }, { label: "中吉", color: "#E67E22", weight: 2 }, { label: "小吉", color: "#F1C40F", weight: 3 }, { label: "吉", color: "#2ECC71", weight: 5 }, { label: "末吉", color: "#3498DB", weight: 8 }, { label: "無念", color: "#95A5A6", weight: 10 } ],
                particleCount: 70,
                particleColors: ['#FFD700', '#FFC107', '#FF9800', '#FF69B4', '#FFFFFF']
            };

            // --- State Variables ---
            let isSpinning = false, soundEnabled = true, isLightMode = false, isInitialized = false;
            let balls = [];
            let spinTargetSpeed = 0, currentSpinSpeed = 0, spinDeceleration = 0.98; // Slightly slower deceleration
            let animationFrameId = null;

            // --- Three.js Variables ---
            let scene, camera, renderer, ambientLight, directionalLight;
            let machineGroup, drumMesh, baseMesh, chuteMesh, topLidMesh, bottomStructureMesh; // Added meshes
            let orbitControls;

            // --- Cannon-es Variables ---
            let world, ballMaterial, wallMaterial; // Removed physicsMaterial (unused)
            let drumBody;
            let cannonDebugger;

            // --- Audio ---
            let sounds = {};
            function setupAudio() {
                try {
                    sounds = {
                        spin: new Howl({ src: ['data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQwAAAAAAACAAA=='], volume: 0.4, loop: true, rate: 1.0 }),
                        win: new Howl({ src: ['data:audio/wav;base64,UklGRiIAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAAAA=='], volume: 0.7 }),
                        click: new Howl({ src: ['data:audio/wav;base64,UklGRigAAAAXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQQAAAAAAA=='], volume: 0.6 }),
                        bounce: new Howl({ src: ['data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQwAAAAAAACAAA=='], volume: 0.1, pool: 15}) // Lower bounce volume, larger pool
                    };
                    Howler.autoUnlock = true;
                    console.log("Audio setup complete.");
                } catch (error) { console.error("Error setting up audio:", error); soundEnabled = false; if (soundStatus) soundStatus.textContent = "音效錯誤"; if(soundToggle) soundToggle.style.pointerEvents = 'none'; }
            }

            // --- Initialization ---
            function init() {
                 if (isInitialized) return; // Prevent double initialization
                 canvasContainer.classList.add('loading'); // Show loading indicator

                 // Check library loading after a short delay to ensure scripts have executed
                 setTimeout(() => {
                     const missingLibs = [];
                     if (typeof THREE === 'undefined') missingLibs.push('Three.js');
                     if (typeof CANNON === 'undefined') missingLibs.push('Cannon-es'); // Check for Cannon-es
                     if (typeof gsap === 'undefined') missingLibs.push('GSAP');
                     if (typeof Draggable === 'undefined') missingLibs.push('GSAP Draggable');
                     if (typeof Howl === 'undefined' || typeof Howler === 'undefined') missingLibs.push('Howler.js');

                     if (missingLibs.length > 0) {
                         console.error("Required libraries failed to load:", missingLibs.join(', '));
                         resultDisplay.textContent = `錯誤：無法載入 ${missingLibs.join(', ')}`;
                         if(startButton) startButton.disabled = true; if(resetButton) resetButton.disabled = true; if(handleDragTrigger) handleDragTrigger.style.display = 'none';
                         canvasContainer.classList.remove('loading');
                         return;
                     }

                     // Proceed with initialization
                     isLightMode = window.innerWidth <= 767;
                     if(isLightMode) document.body.classList.add('light-mode');

                     setupAudio();
                     setupThree();
                     setupCannon();
                     // setupDebuggers();
                     createMachineModel();

                     if (!world || !scene) { // Check if core setups failed
                        canvasContainer.classList.remove('loading');
                        return;
                     }

                     resetLottery(); // This now creates balls and enables controls
                     setupEventListeners(); // Setup listeners after reset enables buttons

                     if (animationFrameId) cancelAnimationFrame(animationFrameId);
                     animate(); // Start animation loop
                     isInitialized = true;
                     console.log("3D抽選機 初始化完成！");
                     canvasContainer.classList.remove('loading'); // Hide loading indicator
                     resultDisplay.textContent = "準備開始抽選"; // Update display text

                 }, 100); // Delay check slightly
            }

            // --- Three.js Setup ---
            function setupThree() {
                 try {
                    scene = new THREE.Scene();
                    const bgColor = getComputedStyle(document.body).getPropertyValue('--background').trim();
                    scene.background = new THREE.Color(bgColor || 0xFDF6E3);
                    scene.fog = new THREE.Fog(scene.background, 7, 20); // Adjusted fog

                    const aspect = canvasContainer.clientWidth / canvasContainer.clientHeight;
                    camera = new THREE.PerspectiveCamera(45, aspect, 0.1, 100); // Slightly narrower FOV
                     // Adjusted Camera Position for better side view framing
                    camera.position.set(config.machineRadius * 4.5, config.machineHeight * 0.4, 0);
                    camera.lookAt(0, -0.2, 0); // Look slightly lower than origin
                    scene.add(camera);

                    renderer = new THREE.WebGLRenderer({ antialias: !isLightMode, alpha: true });
                    renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
                    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); // Further limit pixel ratio
                    renderer.shadowMap.enabled = !isLightMode;
                    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                    renderer.toneMapping = THREE.ACESFilmicToneMapping;
                    renderer.outputColorSpace = THREE.SRGBColorSpace; // Use modern color space
                    canvasContainer.appendChild(renderer.domElement);

                    ambientLight = new THREE.AmbientLight(0xffffff, 0.8); // Adjusted ambient
                    scene.add(ambientLight);

                    directionalLight = new THREE.DirectionalLight(0xffffff, 1.0); // Adjusted directional
                    directionalLight.position.set(5, 10, 3); // Adjusted light angle
                    directionalLight.castShadow = !isLightMode;
                    if(!isLightMode) { /* Shadow settings remain similar */
                         directionalLight.shadow.mapSize.width = 1024; directionalLight.shadow.mapSize.height = 1024;
                         directionalLight.shadow.camera.near = 1; directionalLight.shadow.camera.far = 20;
                         directionalLight.shadow.camera.left = -6; directionalLight.shadow.camera.right = 6;
                         directionalLight.shadow.camera.top = 6; directionalLight.shadow.camera.bottom = -6;
                         directionalLight.shadow.bias = -0.003; // Fine-tuned bias
                    }
                    scene.add(directionalLight);
                    scene.add(directionalLight.target);
                    directionalLight.target.position.set(0, 0, 0);

                    const hemiLight = new THREE.HemisphereLight(0xffeeb1, 0x080820, 0.4); // Warmer top, cooler bottom
                    scene.add(hemiLight);

                    console.log("Three.js setup complete.");
                 } catch (error) { console.error("Error during Three.js setup:", error); if(resultDisplay) resultDisplay.textContent = "錯誤：無法初始化 3D 場景"; scene = null; }
            }

            // --- Cannon-es Setup ---
            function setupCannon() {
                 try {
                    world = new CANNON.World({ gravity: new CANNON.Vec3(0, config.gravity, 0) });
                    world.broadphase = new CANNON.SAPBroadphase(world); // Good general-purpose broadphase
                    world.allowSleep = true; // Enable sleeping for performance
                    world.solver.iterations = 8; // Slightly fewer iterations for performance

                    ballMaterial = new CANNON.Material("ball");
                    wallMaterial = new CANNON.Material("wall");

                    // Define contact properties
                    world.addContactMaterial(new CANNON.ContactMaterial(ballMaterial, wallMaterial, {
                        friction: 0.05, // Low friction against walls
                        restitution: 0.4 // Moderate bounciness off walls
                    }));
                    world.addContactMaterial(new CANNON.ContactMaterial(ballMaterial, ballMaterial, {
                        friction: 0.1, // Some friction between balls
                        restitution: 0.5 // Moderate bounciness between balls
                    }));

                     // Collision event listener (might still be useful for sounds)
                     world.addEventListener('postStep', () => {
                         // Check for collisions to play sound (simplified)
                         // This isn't ideal as it doesn't give impact force easily
                         // But can work as a basic trigger
                         // Example: Check velocity changes after step? (More complex)
                     });


                    console.log("Cannon-es setup complete.");
                 } catch (error) { console.error("Error during Cannon-es setup:", error); if(resultDisplay) resultDisplay.textContent = "錯誤：無法初始化物理引擎"; world = null; }
            }

            // --- Create 3D Models & Physics Bodies ---
            function createMachineModel() {
                 if (!scene || !world) return;
                 try {
                    machineGroup = new THREE.Group();
                    scene.add(machineGroup);

                    const radius = config.machineRadius; const sides = config.numFaces; const height = config.machineHeight;
                    const woodTexture = createWoodTexture();
                     const goldColor = new THREE.Color(getComputedStyle(document.body).getPropertyValue('--gold').trim() || "#D4AF37");

                    // --- Drum Visual (Octagon Cylinder with borders) ---
                    const drumGeometry = new THREE.CylinderGeometry(radius, radius, height, sides, 1, false);
                    const drumMaterial = new THREE.MeshStandardMaterial({
                        color: 0xEEEEEE, // Base color if needed under transmission
                        transmission: 0.95, // Make it more glass-like
                        roughness: 0.05,
                        metalness: 0.0,
                        transparent: true,
                        opacity: 0.85,
                         // thickness: 0.05, // For MeshPhysicalMaterial if used later
                         envMapIntensity: 0.6,
                         side: THREE.FrontSide // Render only front for performance? Try DoubleSide if needed.
                    });
                    drumMesh = new THREE.Mesh(drumGeometry, drumMaterial);
                    drumMesh.position.y = 0;
                    drumMesh.castShadow = false; // Glass doesn't typically cast strong shadows
                    drumMesh.receiveShadow = true; // Can receive shadows
                    machineGroup.add(drumMesh);

                    // Add Edges/Borders for Japanese style
                     const edges = new THREE.EdgesGeometry(drumGeometry);
                     const edgeMaterial = new THREE.LineBasicMaterial({ color: goldColor, linewidth: 1.5 }); // Thicker lines might need LineGeometry/LineMaterial2
                     const wireframe = new THREE.LineSegments(edges, edgeMaterial);
                     wireframe.position.copy(drumMesh.position);
                     machineGroup.add(wireframe);


                    // --- Drum Physics (Cylinder) ---
                    drumBody = new CANNON.Body({ mass: 0, type: CANNON.Body.KINEMATIC, material: wallMaterial });
                    const drumShapePhysics = new CANNON.Cylinder(radius, radius, height, sides);
                    drumBody.addShape(drumShapePhysics); drumBody.position.set(0, 0, 0);
                    world.addBody(drumBody);

                    // --- Top Lid Visual (Japanese Style) ---
                    const lidRadius = radius * 1.05;
                    const lidHeight = 0.15;
                    const lidGeometry = new THREE.CylinderGeometry(lidRadius * 0.8, lidRadius, lidHeight, sides * 2); // Tapered lid
                    const lidMaterial = new THREE.MeshStandardMaterial({ color: goldColor, roughness: 0.3, metalness: 0.6 });
                    topLidMesh = new THREE.Mesh(lidGeometry, lidMaterial);
                    topLidMesh.position.y = height / 2 + lidHeight / 2 - 0.01; // Position above drum
                    topLidMesh.castShadow = true;
                    machineGroup.add(topLidMesh);

                     // --- Bottom Structure Visual (Wooden Base + Frame) ---
                    const baseHeight = 0.3;
                    const baseGeometry = new THREE.CylinderGeometry(radius * 1.1, radius * 1.25, baseHeight, 16);
                    const baseMaterial = new THREE.MeshStandardMaterial({ map: woodTexture, roughness: 0.8, metalness: 0.1 });
                    baseMesh = new THREE.Mesh(baseGeometry, baseMaterial);
                    baseMesh.position.y = -height / 2 - baseHeight / 2;
                    baseMesh.receiveShadow = true;
                    machineGroup.add(baseMesh);

                     // Add some frame structure (simple boxes)
                     const frameMaterial = new THREE.MeshStandardMaterial({ map: woodTexture, roughness: 0.7 });
                     const frameThickness = 0.1;
                     const frameHeight = 0.6;
                     const framePositions = [
                         { x: radius * 1.1, z: 0 }, { x: -radius * 1.1, z: 0 },
                         { x: 0, z: radius * 1.1 }, { x: 0, z: -radius * 1.1 }
                     ];
                     framePositions.forEach(pos => {
                         const frameGeo = new THREE.BoxGeometry(frameThickness, frameHeight, frameThickness);
                         const frameMesh = new THREE.Mesh(frameGeo, frameMaterial);
                         frameMesh.position.set(pos.x, baseMesh.position.y + frameHeight / 2, pos.z);
                         frameMesh.castShadow = true;
                         machineGroup.add(frameMesh);
                     });


                    // --- Chute Visual ---
                    const chuteMaterial = new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 0.5 }); // Darker chute
                    const chuteSize = config.ballRadius * 2.5;
                    const chuteGeometry = new THREE.BoxGeometry(chuteSize * 1.2, 0.4, chuteSize); // Slightly adjusted shape
                    chuteMesh = new THREE.Mesh(chuteGeometry, chuteMaterial);
                    // Position below base, offset towards camera
                    chuteMesh.position.set(0, baseMesh.position.y - baseHeight/2 - 0.2, radius * 0.7);
                    machineGroup.add(chuteMesh);

                    // --- Static Ground Plane (Physics) ---
                    const groundBody = new CANNON.Body({ type: CANNON.Body.STATIC, material: wallMaterial });
                    groundBody.addShape(new CANNON.Plane());
                    groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
                    groundBody.position.y = baseMesh.position.y - baseHeight/2 - 0.3; // Place it below chute exit
                    world.addBody(groundBody);

                    console.log("Machine model created.");
                 } catch (error) { console.error("Error creating machine model:", error); if(resultDisplay) resultDisplay.textContent = "錯誤：無法創建抽選機模型"; }
            }
            // --- Wood Texture Helper ---
            function createWoodTexture() {
                 const canvas = document.createElement('canvas'); canvas.width = 128; canvas.height = 256; // Higher res
                 const context = canvas.getContext('2d');
                 // Base Color
                 const baseColor = getComputedStyle(document.body).getPropertyValue('--primary-dark').trim() || '#8C5E2A';
                 context.fillStyle = baseColor; context.fillRect(0, 0, 128, 256);
                 // Grain
                 const grainColor = `rgba(0, 0, 0, 0.15)`; // Darker grain
                 context.lineWidth = 0.5;
                 context.strokeStyle = grainColor;
                 for (let i = 0; i < 30; i++) { // Fewer, more distinct lines
                     context.beginPath();
                     context.moveTo(Math.random() * 128, 0);
                     context.bezierCurveTo(
                         Math.random() * 128, 85,
                         Math.random() * 128, 170,
                         Math.random() * 128, 256);
                     context.stroke();
                 }
                 const texture = new THREE.CanvasTexture(canvas); texture.wrapS = THREE.RepeatWrapping; texture.wrapT = THREE.RepeatWrapping; texture.repeat.set(2, 1); return texture;
             }

            // --- Create Balls (With independent materials) ---
            function createBalls(count) {
                 if (!scene || !world) return;
                 try {
                    // Clear previous balls more safely
                    balls.forEach(ball => {
                        if (ball.mesh) {
                            if(ball.mesh.geometry) ball.mesh.geometry.dispose();
                            if(ball.mesh.material) {
                                // Dispose textures if they were created per ball
                                if (ball.mesh.material.map) ball.mesh.material.map.dispose();
                                ball.mesh.material.dispose();
                            }
                            scene.remove(ball.mesh);
                        }
                        if (ball.body) world.removeBody(ball.body);
                    });
                    balls = [];

                    let weightedPrizes = [];
                    config.prizes.forEach(prize => { for (let i = 0; i < prize.weight; i++) weightedPrizes.push(prize); });

                    const ballGeometry = new THREE.SphereGeometry(config.ballRadius, 16, 12); // Shared geometry
                    const ballShape = new CANNON.Sphere(config.ballRadius);
                    const textCanvas = document.createElement('canvas'); const textCtx = textCanvas.getContext('2d'); textCanvas.width = 64; textCanvas.height = 32;

                    // Pre-calculate spawn area limits
                    const maxSpawnRadius = config.machineRadius * 0.8 - config.ballRadius;
                    const maxSpawnHeight = config.machineHeight * 0.8 / 2 - config.ballRadius;


                    for (let i = 0; i < count; i++) {
                        const prizeData = weightedPrizes[Math.floor(Math.random() * weightedPrizes.length)];
                        // Create unique texture per ball
                        textCtx.fillStyle = prizeData.color; textCtx.fillRect(0, 0, 64, 32); textCtx.fillStyle = 'white'; textCtx.font = 'bold 14px Noto Sans TC'; textCtx.textAlign = 'center'; textCtx.textBaseline = 'middle'; textCtx.fillText(prizeData.label, 32, 16);
                        const ballTexture = new THREE.CanvasTexture(textCanvas);
                        ballTexture.needsUpdate = true; // Ensure texture updates

                        // *** Create unique material per ball ***
                        const ballMaterialInstance = new THREE.MeshStandardMaterial({
                            map: ballTexture, roughness: 0.4, metalness: 0.1
                        });

                        const ballMesh = new THREE.Mesh(ballGeometry, ballMaterialInstance);
                        ballMesh.castShadow = true; ballMesh.receiveShadow = true; ballMesh.userData.prize = prizeData;

                        // Attempt non-overlapping spawn (simple repulsion)
                        let spawnPos, isOverlapping;
                        let attempts = 0;
                        const maxAttempts = 20;
                        do {
                            isOverlapping = false;
                            const angle = Math.random() * Math.PI * 2;
                            const radius = Math.random() * maxSpawnRadius;
                            spawnPos = new CANNON.Vec3(
                                radius * Math.cos(angle),
                                (Math.random() - 0.5) * maxSpawnHeight,
                                radius * Math.sin(angle)
                            );
                            // Check against existing balls
                            for(const existingBall of balls) {
                                if(existingBall.body.position.distanceTo(spawnPos) < config.ballRadius * 2.1) { // Check distance + slight buffer
                                    isOverlapping = true;
                                    break;
                                }
                            }
                            attempts++;
                        } while (isOverlapping && attempts < maxAttempts);

                        if (attempts >= maxAttempts) {
                             console.warn("Could not find non-overlapping position, placing randomly.");
                             // Fallback to random placement if too many attempts fail
                             const angle = Math.random() * Math.PI * 2; const radius = Math.random() * maxSpawnRadius;
                             spawnPos = new CANNON.Vec3( radius * Math.cos(angle), (Math.random()-0.5)*maxSpawnHeight, radius * Math.sin(angle) );
                         }


                        const ballBody = new CANNON.Body({
                            mass: 0.1, shape: ballShape, material: ballMaterial,
                            position: spawnPos, // Use calculated position
                            angularVelocity: new CANNON.Vec3((Math.random()-0.5)*3, (Math.random()-0.5)*3, (Math.random()-0.5)*3), // Reduced initial tumble
                            linearDamping: 0.15, angularDamping: 0.15, allowSleep: true, sleepSpeedLimit: 0.1, sleepTimeLimit: 0.8 // Adjust sleep parameters
                        });
                        ballBody.userData = { mesh: ballMesh, lastCollisionTime: 0 }; // Add collision time tracking

                        world.addBody(ballBody); scene.add(ballMesh);
                        balls.push({ mesh: ballMesh, body: ballBody, prize: prizeData });
                    }
                    console.log(`創建了 ${balls.length} 個 3D 球`);
                 } catch (error) { console.error("Error creating balls:", error); if(resultDisplay) resultDisplay.textContent = "錯誤：無法創建球體"; }
            }


            // --- Animation Loop (Add bounce sound trigger) ---
            const clock = new THREE.Clock();
            let lastCollisionCheckTime = 0;
            function animate() {
                 animationFrameId = requestAnimationFrame(animate);
                 const deltaTime = clock.getDelta();
                 const dt = config.physicsTimeStep;

                 if (!scene || !world || !camera || !renderer) { if(animationFrameId) cancelAnimationFrame(animationFrameId); return; }
                 try {
                     // Spin Control
                     if (isSpinning) { /* ... */ } else { /* ... */ }
                     // Update Drum Rotation
                     if (drumBody && Math.abs(currentSpinSpeed) > 0) { /* ... */ }

                     // Step Physics
                     world.step(dt);

                     // Update Visuals & Check Collisions for Sound
                     const now = performance.now();
                     let playBounceThisFrame = false; // Limit sound playback per frame

                     for (const ball of balls) {
                         if (ball.body && ball.mesh) {
                             ball.mesh.position.copy(ball.body.position);
                             ball.mesh.quaternion.copy(ball.body.quaternion);

                              // Simple Bounce Sound Trigger based on velocity change (less accurate)
                             // More reliable: Check contacts (requires more setup or library support)
                             // Basic check: if vertical velocity flips sign and is significant
                             // This part needs Cannon.js specific collision event handling if available or approximation
                         }
                     }
                     if (drumMesh && drumBody) { drumMesh.quaternion.copy(drumBody.quaternion); }

                     // Update Debuggers/Controls
                     if (orbitControls) orbitControls.update();
                     // if (cannonDebugger) cannonDebugger.update();

                     renderer.render(scene, camera);
                 } catch (error) { console.error("Error during animation loop:", error); if(animationFrameId) cancelAnimationFrame(animationFrameId); if(resultDisplay) resultDisplay.textContent = "錯誤：動畫循環失敗"; }
            }


            // --- Event Listeners & Interaction ---
            function setupEventListeners() {
                 if (!handleDragTrigger || !startButton || !resetButton || !soundToggle || !closeWinner) { console.error("UI elements missing."); return; }
                 try {
                    startButton.addEventListener('click', handleSpinButtonClick);
                    resetButton.addEventListener('click', handleResetClick);
                    soundToggle.addEventListener('click', toggleSound);
                    closeWinner.addEventListener('click', hideWinnerDisplay);

                    // *** Crucial Check for Draggable ***
                    if (typeof Draggable !== 'undefined') {
                        Draggable.create(handleDragTrigger, {
                            type: "y", trigger: handleDragTrigger, inertia: true, throwResistance: 4000, cursor: 'grab', activeCursor: 'grabbing',
                            onDragStart: function() { if (isSpinning) return; if (soundEnabled && sounds.click) sounds.click.play(); gsap.to(handleDragTrigger, { scale: 1.1, duration: 0.1 }); },
                            onDragEnd: function() {
                                gsap.to(handleDragTrigger, { scale: 1, duration: 0.3 }); gsap.to(this.target, { y: 0, duration: 0.5, ease: "power2.out" });
                                const finalVelocityY = this.getVelocity("y"); const angularVelFromDrag = -finalVelocityY * 0.015 * config.handleSensitivity;
                                if (Math.abs(angularVelFromDrag) > config.minSpinVelocity && !isSpinning) { startSpin(angularVelFromDrag, config.baseSpinDuration); }
                            }
                        });
                    } else {
                        console.error("GSAP Draggable is not loaded! Interaction disabled.");
                        handleDragTrigger.style.display = 'none'; // Hide trigger if Draggable unavailable
                    }
                    window.addEventListener('resize', onWindowResize, false);
                    console.log("Event listeners set up.");
                 } catch (error) { console.error("Error setting up event listeners:", error); if(resultDisplay) resultDisplay.textContent = "錯誤：無法設定互動功能"; }
            }
            // --- onWindowResize (no changes) ---
            function onWindowResize() { /* ... */ }

            // --- Spin Logic (no changes) ---
            function startSpin(initialVelocityRad = 0, duration) { /* ... */ }
            function stopSpinning() { /* ... */ }
            function determineWinner() { /* ... */ }

            // --- Display Result & Ejection (no changes) ---
            function displayResult(winner) { /* ... */ }
            function ejectBall(winner) { /* ... */ }

            // --- Helper Functions (no changes) ---
            function setControlsDisabled(disabled) { /* ... */ }
            function toggleSound() { /* ... */ }
            function triggerParticleEffect(targetMesh) { /* ... */ }
            function toScreenPosition(obj, camera, rendererContainer) { /* ... */ }
            function showWinnerDisplay(winner) { /* ... */ }
            function hideWinnerDisplay() { /* ... */ }

            // --- Reset (Enable controls at the end) ---
            function resetLottery() {
                if (!world || !scene) { console.error("Cannot reset, world or scene not initialized."); return; }
                try {
                    if (isSpinning) { /* Stop spin */ }
                    if (drumBody) { /* Reset drum */ } if (drumMesh) { /* Reset drum mesh */ }
                    // Clear existing balls safely
                    balls.forEach(ball => {
                         if (ball.mesh) scene.remove(ball.mesh);
                         if (ball.body) world.removeBody(ball.body);
                     });
                     balls = []; // Clear array

                    const ballCount = parseInt(ballCountInput.value, 10);
                    const validBallCount = Math.max(5, Math.min(30, isNaN(ballCount) ? 15 : ballCount));
                    ballCountInput.value = validBallCount;
                    createBalls(validBallCount); // Create new balls

                    if(resultDisplay) { resultDisplay.textContent = "準備開始抽選"; resultDisplay.classList.remove('winning'); }
                    hideWinnerDisplay();
                    setControlsDisabled(false); // *** Enable controls AFTER reset is complete ***
                    console.log("Lottery reset complete.");
                } catch(error) { console.error("Error during resetLottery:", error); if(resultDisplay) resultDisplay.textContent = "錯誤：重置抽選機失敗"; setControlsDisabled(true); } // Disable controls on error
            }

            // --- Start Application ---
            document.addEventListener('DOMContentLoaded', init); // Ensure DOM is ready

        })(); // End IIFE
    </script>

</body>
</html>