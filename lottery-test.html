<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>御縁の抽選機 - 日式八角抽選機</title>
    <!-- Fonts, Libs, Styles (Keep Stylesheet from previous correct version) -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&family=Noto+Serif+JP:wght@400;700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.4/howler.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
    <style>
        /* --- PASTE THE FULL CSS FROM THE PREVIOUS CORRECT ANSWER HERE --- */
        /* For brevity, I'm omitting the full CSS block, but it's crucial */
        :root {
            --primary: #B28046;
            --primary-light: #D4AF6A;
            --primary-dark: #8C5E2A;
            --accent: #9E2A2B;
            --background: #F5F5F0;
            --text: #33281E;
            --glass: rgba(255, 255, 255, 0.25);
            --gold-gradient: linear-gradient(135deg, #D4AF37 0%, #F1DB8B 40%, #F8F4E3 50%, #F1DB8B 60%, #D4AF37 100%);
            --wooden-gradient: linear-gradient(135deg, #8B4513 0%, #A0522D 50%, #8B4513 100%);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Noto Sans TC', sans-serif;
            background-color: var(--background);
            background-image: 
                radial-gradient(circle at 100% 0%, rgba(178, 128, 70, 0.15) 0%, transparent 60%), 
                radial-gradient(circle at 0% 100%, rgba(158, 42, 43, 0.1) 0%, transparent 50%);
            color: var(--text);
            overflow-x: hidden;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            padding: 20px;
        }
        
        .title-area {
            text-align: center;
            margin-bottom: 20px;
            padding: 10px;
            position: relative;
            z-index: 10;
        }
        
        .title-area h1 {
            font-family: 'Noto Serif JP', serif;
            font-size: 2.5rem;
            color: var(--primary-dark);
            margin-bottom: 5px;
            letter-spacing: 2px;
            position: relative;
            display: inline-block;
        }
        
        .title-area h1::after {
            content: '';
            position: absolute;
            bottom: -8px;
            left: 10%;
            width: 80%;
            height: 2px;
            background: var(--gold-gradient);
        }
        
        .title-area p {
            font-size: 1rem;
            color: var(--text);
            opacity: 0.8;
        }
        
        /* 主要抽選機容器 */
        .lottery-scene {
            position: relative;
            width: 100%;
            max-width: 800px; /* 增加寬度容納手把 */
            height: 600px; /* 增加高度 */
            perspective: 1200px;
            margin: 0 auto;
            /* outline: 1px dashed red; */ /* Debug: 顯示邊界 */
        }
        
        /* 八角形抽選機 */
        .lottery-machine {
            position: absolute;
            top: 50%;
            left: 50%;
            /* 調整中心點 */
            transform: translate(-50%, -50%) rotateX(10deg);
            transform-style: preserve-3d;
            width: 320px; /* 八角柱直徑相關 */
            height: 320px; /* 八角柱高度 */
            transition: transform 0.5s ease;
            /* outline: 1px dashed blue; */ /* Debug: 顯示邊界 */
        }
        
        .octagon {
            position: absolute;
            width: 100%; /* 與 .lottery-machine 相同 */
            height: 100%; /* 與 .lottery-machine 相同 */
            transform-style: preserve-3d;
        }
        
        /* 八個面 */
        .octagon-face {
            position: absolute;
            /* 調整 positioning 使中心對齊 lottery-machine 中心 */
            top: 0;
            left: calc(50% - 70px); /* (320 - 140) / 2 = 90 不對, 應該是 (父寬度 - 自身寬度) / 2 */
                                     /* left: calc(50% - 70px);  => width 140px, 所以 left = 50% - 70px */
            width: 140px; /* 面寬 */
            height: 320px; /* 面高 = 八角柱高 */
            background: var(--glass);
            border: 2px solid var(--primary-light);
            backdrop-filter: blur(5px);
            box-shadow: inset 0 0 15px rgba(255, 255, 255, 0.5);
            /* 旋轉和位移的原點設在父容器中心 */
            transform-origin: center center;
            transform-style: preserve-3d;
            overflow: hidden; /* 隱藏超出邊界的球 */
        }
        
        .octagon-face::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, 
                        rgba(255, 255, 255, 0.4) 0%, 
                        rgba(255, 255, 255, 0.1) 50%, 
                        rgba(255, 255, 255, 0) 100%);
            pointer-events: none;
        }
        
        /* 八角形頂部與底部 */
        .top-cap, .bottom-cap {
            position: absolute;
            /* 寬高應約等於八角柱的外接圓直徑, 或略大 */
            /* 外接圓半徑 R = a / cos(pi/8) = 140 / cos(22.5) ≈ 151.5 */
            /* 直徑 ≈ 303px. 邊長 s = 2 * a * tan(pi/8) = 2 * 140 * tan(22.5) ≈ 116 */
            /* 此處 260px 是一個視覺選擇 */
            width: 282px; /* 根據 translateZ=140 計算的邊到邊距離約 2*140 = 280 */
            height: 282px;
            left: 50%;
            /* X軸旋轉90度成為平面 */
            transform: translateX(-50%) rotateX(90deg);
            background: var(--gold-gradient);
            /* 改成八角形 */
            clip-path: polygon(30% 0%, 70% 0%, 100% 30%, 100% 70%, 70% 100%, 30% 100%, 0% 70%, 0% 30%);
            /* border-radius: 50%; */ /* 改用 clip-path */
            transform-style: preserve-3d;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
        }
        
        .top-cap {
            /* Z 軸位移 = 八角柱高度 / 2 */
            transform: translateX(-50%) rotateX(90deg) translateZ(160px);
            background-image: var(--gold-gradient);
        }
        
        /* 頂部裝飾移除或修改 */
        /* .top-cap::after { ... } */
        
        .bottom-cap {
            /* Z 軸位移 = - 八角柱高度 / 2 */
            transform: translateX(-50%) rotateX(90deg) translateZ(-160px);
            background-image: var(--wooden-gradient);
        }
        
        /* 手把 */
        .handle-container {
            position: absolute;
            width: 40px;
            height: 300px;
            /* 放在抽選機右側外部 */
            right: -120px; /* 調整位置使其不重疊 */
            top: 50%;
            transform: translateY(-50%);
            cursor: grab;
            z-index: 5;
            transform-style: preserve-3d;
             /* outline: 1px dashed green; */ /* Debug: 顯示邊界 */
        }
        
        .handle {
            position: absolute;
            width: 40px;
            height: 200px;
            background-color: var(--primary-dark);
            border-radius: 20px;
            bottom: 30px; /* 抬高一點以容納底座 */
            /* 旋轉中心在底部 */
            transform-origin: bottom center;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
        }
        
        .handle-knob {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: var(--gold-gradient);
            top: -30px; /* 旋鈕中心對齊手把頂部 */
            left: 50%;
            transform: translateX(-50%);
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.4);
            border: 3px solid #D4AF37;
        }
        
        .handle-base {
            position: absolute;
            width: 80px;
            height: 40px;
            background: var(--wooden-gradient);
            border-radius: 10px;
            bottom: 0px; /* 手把底部 */
            left: 50%;
            transform: translateX(-50%);
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.2);
        }
        
        /* 抽選球 */
        .ball {
            position: absolute;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            text-align: center;
            line-height: 40px;
            font-weight: bold;
            font-size: 1rem; /* 稍微縮小字體以適應球大小 */
            transform-style: preserve-3d;
            box-shadow: inset 0 0 8px rgba(0, 0, 0, 0.2), 0 0 4px rgba(0, 0, 0, 0.3);
            color: white;
            text-shadow: 1px 1px 1px rgba(0, 0, 0, 0.5);
            /* 初始位置由 JS 設定 */
            /* 球的 transform-origin 應在中心 */
            transform-origin: center center;
            /* 添加 will-change 提升動畫效能 */
            will-change: transform, opacity;
            /* Ensure balls are visible initially */
            opacity: 0.8; /* Start with some opacity */
        }
        
        /* 控制面板 */
        .control-panel {
            position: relative;
            width: 100%;
            max-width: 600px;
            margin: 30px auto 0; /* 調整 margin-top */
            padding: 20px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            text-align: center;
            border: 1px solid var(--primary-light);
            z-index: 20;
        }
        
        .result-display {
            font-size: 1.5rem;
            font-weight: bold;
            margin: 15px 0;
            padding: 10px;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 5px;
            background-color: rgba(245, 245, 240, 0.7);
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.1);
            color: var(--text);
            transition: background-color 0.5s, color 0.5s;
        }
        
        .result-display.winning {
            background-color: var(--primary-light);
            color: var(--text);
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.1), 0 0 0 0 rgba(178, 128, 70, 0.4); }
            70% { box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.1), 0 0 0 10px rgba(178, 128, 70, 0); }
            100% { box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.1), 0 0 0 0 rgba(178, 128, 70, 0); }
        }
        
        .button {
            background: var(--primary);
            color: white;
            border: none;
            padding: 12px 25px;
            font-size: 1rem;
            border-radius: 30px;
            cursor: pointer;
            margin: 5px;
            font-weight: 500;
            letter-spacing: 1px;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.15);
            transition: all 0.3s ease;
            font-family: 'Noto Sans TC', sans-serif;
        }
        
        .button:hover {
            background: var(--primary-dark);
            transform: translateY(-2px);
            box-shadow: 0 5px 12px rgba(0, 0, 0, 0.2);
        }
        
        .button.start {
            background: var(--accent);
        }
        
        .button.start:hover {
            background: #7D2122;
        }
        
        .button:disabled {
            background: #cccccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            opacity: 0.7;
        }
        
        /* 設定面板 */
        .settings-panel {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(0, 0, 0, 0.1);
        }
        
        .settings-panel h3 {
            margin-bottom: 10px;
            font-size: 1.1rem;
            color: var(--text);
        }
        
        .settings-row {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 10px;
        }
        
        .input-group {
            display: flex;
            align-items: center;
        }
        
        .input-group label {
            margin-right: 8px;
            font-size: 0.9rem;
        }
        
        .input-group input, .input-group select {
            padding: 8px;
            border-radius: 5px;
            border: 1px solid #ddd;
            font-family: inherit;
            min-width: 70px; /* 避免過窄 */
        }
        
        /* 粒子效果 */
        .particles-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 30;
            overflow: hidden;
        }
        
        .particle {
            position: absolute;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            opacity: 0;
            will-change: transform, opacity; /* 提升動畫效能 */
        }
        
        /* 燈光效果 */
        .spotlight {
            position: absolute;
            /* 調整位置和大小，使其聚焦於機器 */
            top: 50%;
            left: 50%;
            width: 500px; /* 稍微縮小 */
            height: 500px;
            transform: translate(-50%, -50%); /* 中心對齊 */
            background: radial-gradient(
                ellipse at center,
                rgba(255, 255, 220, 0.5) 0%, /* 稍微偏黃的光 */
                rgba(255, 255, 255, 0) 70%
            );
            border-radius: 50%; /* 確保是圓形 */
            pointer-events: none;
            opacity: 0;
            z-index: 2; /* 放在機器後面但在背景之上 */
            transition: opacity 1s ease; /* 使用 CSS transition */
        }
        
        /* 獎項顯示區 */
        .winner-display {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }
        
        .winner-display.show {
            opacity: 1;
            pointer-events: auto;
        }
        
        .winner-content {
            background: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            max-width: 80%;
            box-shadow: 0 0 30px rgba(255, 215, 0, 0.5);
            transform: scale(0.8);
            transition: transform 0.5s ease;
        }
        
        .winner-display.show .winner-content {
            transform: scale(1);
        }
        
        .winner-ball {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            margin: 0 auto 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.5rem;
            font-weight: bold;
            color: white;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.3);
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.5);
            transition: background-color 0.3s;
        }
        
        .winner-title {
            font-size: 1.8rem;
            color: var(--accent);
            margin-bottom: 10px;
            font-family: 'Noto Serif JP', serif;
        }
        
        .winner-message {
            font-size: 1.2rem;
            margin-bottom: 20px;
        }
        
        .close-button {
            background: var(--primary);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 30px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s ease;
        }
        
        .close-button:hover {
            background: var(--primary-dark);
        }
        
        /* 音效控制 */
        .sound-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-top: 10px;
        }
        
        .sound-toggle {
            display: flex;
            align-items: center;
            margin-left: 15px;
            cursor: pointer;
            user-select: none; /* 防止文字被選取 */
        }
        
        .sound-toggle i {
            margin-right: 5px;
            color: var(--primary);
            width: 1.2em; /* 固定圖標寬度 */
            text-align: center;
        }
        
        /* 響應式設計 */
        @media (max-width: 767px) {
            body {
                padding: 10px; /* 減少邊距 */
            }
            .title-area h1 {
                font-size: 1.8rem;
            }
            .title-area p {
                font-size: 0.9rem;
            }
            .lottery-scene {
                height: 450px;
                max-width: 100%;
                perspective: 1000px; /* 減少透視 */
            }
            
            .lottery-machine {
                width: 240px; /* 縮小機器 */
                height: 240px;
            }
            
            .octagon-face {
                width: 100px; /* 縮小面寬 */
                height: 240px; /* 縮小面高 */
                left: calc(50% - 50px); /* 重新計算 left */
                /* translateZ 需要根據新的寬度和八角形要求重新計算 */
                /* 如果保持八角形, translateZ = (100 / 2) / tan(pi / 8) ≈ 120.7 */
                /* 使用 100px 保持比例 */
                /* transform is set dynamically by JS in createOctagon */
            }

            .top-cap, .bottom-cap {
                /* 根據新的 translateZ=100 計算 */
                width: 200px; /* approx 2 * 100 */
                height: 200px;
                 /* clip-path 保持不變 */
            }
            .top-cap {
                transform: translateX(-50%) rotateX(90deg) translateZ(120px); /* height/2 = 240/2 */
            }
            .bottom-cap {
                 transform: translateX(-50%) rotateX(90deg) translateZ(-120px); /* -height/2 */
            }
            
            .handle-container {
                right: -60px; /* 靠近一點 */
                height: 220px; /* 縮小 */
            }
            
            .handle {
                height: 150px; /* 縮小 */
                bottom: 20px;
            }
             .handle-knob {
                width: 50px;
                height: 50px;
                top: -25px;
            }
            .handle-base {
                width: 60px;
                height: 30px;
                bottom: 0px;
            }

            .ball {
                width: 30px; /* Smaller balls */
                height: 30px;
                line-height: 30px;
                font-size: 0.8rem; /* 縮小字體 */
            }
            
            .control-panel {
                padding: 15px;
                margin-top: 20px;
            }
            .result-display {
                font-size: 1.2rem;
                min-height: 50px;
            }
             .button {
                padding: 10px 20px;
                font-size: 0.9rem;
            }

            .settings-row {
                flex-direction: column;
                align-items: stretch;
                gap: 10px;
            }
            .input-group {
                justify-content: space-between;
            }
            .input-group input, .input-group select {
                padding: 6px;
                flex-grow: 1; /* 讓輸入框填滿空間 */
                margin-left: 10px;
            }

            .winner-content {
                padding: 20px;
                max-width: 90%; /* 稍微增加寬度 */
            }
            .winner-ball {
                width: 80px;
                height: 80px;
                font-size: 2rem;
            }
             .winner-title {
                font-size: 1.5rem;
            }
            .winner-message {
                font-size: 1rem;
            }
            .close-button {
                padding: 8px 16px;
                font-size: 0.9rem;
            }
        }
        
        /* 輕量模式的樣式 */
        body.light-mode .octagon-face {
            backdrop-filter: none; /* 移除模糊效果 */
            background: rgba(212, 175, 106, 0.5); /* 使用半透明純色替代 */
        }
        body.light-mode .ball {
             box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.1); /* 簡化陰影 */
        }
    </style>
</head>
<body>
    <!-- HTML Structure (Keep from previous correct version) -->
     <!-- 標題區域 -->
    <div class="title-area">
        <h1>御縁の抽選機</h1>
        <p>緣分天注定，運勢在此時</p>
    </div>
    
    <!-- 主要抽選機場景 -->
    <div class="lottery-scene">
        <!-- 燈光效果 -->
        <div class="spotlight"></div>
        
        <!-- 八角形抽選機 -->
        <div class="lottery-machine">
            <div class="octagon" id="octagon">
                <!-- 八個面會被JS動態生成 -->
            </div>
            <div class="top-cap"></div>
            <div class="bottom-cap"></div>
        </div>
        
        <!-- 手把 -->
        <div class="handle-container" id="handleContainer">
            <div class="handle">
                <div class="handle-knob"></div>
            </div>
            <div class="handle-base"></div>
        </div>
    </div>
    
    <!-- 控制面板 -->
    <div class="control-panel">
        <div class="result-display" id="resultDisplay">
            準備開始抽選...
        </div>
        <div>
            <button class="button start" id="startButton">開始抽選</button>
            <button class="button" id="resetButton">重新設置</button>
        </div>
        
        <!-- 設定面板 -->
        <div class="settings-panel">
            <h3>抽選設定</h3>
            <div class="settings-row">
                <div class="input-group">
                    <label for="ballCount">球數量:</label>
                    <input type="number" id="ballCount" min="5" max="30" value="15">
                </div>
                <div class="input-group">
                    <label for="spinSpeed">轉速:</label>
                    <select id="spinSpeed">
                        <option value="slow">慢速</option>
                        <option value="medium" selected>中速</option>
                        <option value="fast">快速</option>
                    </select>
                </div>
                <div class="sound-controls">
                    <div class="sound-toggle" id="soundToggle">
                        <i class="fas fa-volume-up"></i> <span id="soundStatus">音效開啟</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- 粒子效果容器 -->
    <div class="particles-container" id="particlesContainer"></div>
    
    <!-- 獎項顯示區 -->
    <div class="winner-display" id="winnerDisplay">
        <div class="winner-content">
            <div class="winner-ball" id="winnerBall"></div>
            <h2 class="winner-title">恭喜中獎！</h2>
            <p class="winner-message" id="winnerMessage">您抽中了神秘獎項！</p>
            <button class="close-button" id="closeWinner">確認</button>
        </div>
    </div>
    
    <!-- JavaScript -->
    <script>
        // Wrap in try...catch for better error reporting during init
        try {
            document.addEventListener('DOMContentLoaded', function() {
                console.log("DOM Loaded. Initializing script..."); // DEBUG

                // --- DOM Elements ---
                const octagonContainer = document.getElementById('octagon');
                const handleContainer = document.getElementById('handleContainer');
                const handle = handleContainer.querySelector('.handle');
                const resultDisplay = document.getElementById('resultDisplay');
                const startButton = document.getElementById('startButton');
                const resetButton = document.getElementById('resetButton');
                const ballCountInput = document.getElementById('ballCount');
                const spinSpeedSelect = document.getElementById('spinSpeed');
                const soundToggle = document.getElementById('soundToggle');
                const soundStatus = document.getElementById('soundStatus');
                const particlesContainer = document.getElementById('particlesContainer');
                const spotlight = document.querySelector('.spotlight');
                const winnerDisplay = document.getElementById('winnerDisplay');
                const winnerBall = document.getElementById('winnerBall');
                const winnerMessage = document.getElementById('winnerMessage');
                const closeWinner = document.getElementById('closeWinner');
                const lotteryMachine = document.querySelector('.lottery-machine'); // Get machine element

                 // --- Verify Element Selection ---
                 if (!octagonContainer) console.error("ERROR: Cannot find #octagon");
                 if (!handleContainer) console.error("ERROR: Cannot find #handleContainer");
                 if (!lotteryMachine) console.error("ERROR: Cannot find .lottery-machine");
                 // ... add checks for other critical elements if needed

                // --- State Variables ---
                let isSpinning = false;
                let currentSpinSpeed = 0;
                let spinAngle = 0;
                let balls = [];
                let soundEnabled = true;
                let isLightMode = false;
                let dragStartY = 0;
                let handleAngle = 0;
                let handleVelocity = 0;
                let lastDragY = 0;
                let isDragging = false;
                let animationFrameId = null;
                let spinStartTime = 0;
                let isDecelerating = false;

                // --- Constants ---
                const DECELERATION_FACTOR = 0.995;
                const MIN_SPIN_SPEED = 0.1;
                const HANDLE_DRAG_THRESHOLD = 8; // Lowered threshold slightly
                const SPIN_DURATION_BEFORE_DECEL = 3000 + Math.random() * 2000;

                // --- Dynamic Ball Size ---
                 function getBallDiameter() {
                    return window.innerWidth <= 767 ? 30 : 40;
                }
                function getBallRadius() {
                    return getBallDiameter() / 2;
                }


                // --- Physics Constants ---
                const GRAVITY = 0.03;
                const FRICTION = 0.98;
                const BOUNDARY_ELASTICITY = 0.6; // Slightly less bouncy
                const BALL_COLLISION_DAMPING = 0.8; // Slightly less bouncy collisions

                // --- Prize Definitions ---
                const prizes = [
                    { label: "大吉", color: "#E74C3C", weight: 1 },
                    { label: "中吉", color: "#E67E22", weight: 2 },
                    { label: "小吉", color: "#F1C40F", weight: 3 },
                    { label: "吉", color: "#2ECC71", weight: 5 },
                    { label: "末吉", color: "#3498DB", weight: 8 },
                    { label: "凶", color: "#9B59B6", weight: 3 },
                    { label: "大凶", color: "#34495E", weight: 1 }
                ];
                
                // --- Sound Effects ---
                // Ensure Base64 strings are correct or replace with file paths
                // Howler setup remains the same...
                 const sounds = {
                    spin: new Howl({
                        src: ['data:audio/mp3;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU4Ljc2LjEwMAAAAAAAAAAAAAAA//tQwAAAAAAAAAAAAAAAAAAAAAAASW5mbwAAAA8AAAASAAAeMwAUFBQUHh4eHh4qKioqKioqNDQ0NDRAQEBAQEBMTExMTExMWFhYWFhkZGRkZGRwcHBwcHB8fHx8fHyIiIiIiIiIlJSUlJSUnJycnJyouLi4uLi4xMTExMTE0NDQ0NDQ0NDc3Nzc3Nzc6Ojo6Oj09PT09PT///8AAAAATGF2YzU4LjEzAAAAAAAAAAAAAAAAJAQoAAAAAAAeMwGvI84AAAAAAAAAAAAAAAAA//uQwAALcABEnCAAACNCwQnG8gAQAYRERERERERRAAIR5zjn5uecIQhEQnOOcABAIBAMBAIThCcIQhCEIQiIiIiRERERI='],
                        volume: 0.4, loop: true
                    }),
                    win: new Howl({
                        src: ['data:audio/mp3;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU4Ljc2LjEwMAAAAAAAAAAAAAAA//tQwAAAAAAAAAAAAAAAAAAAAAAASW5mbwAAAA8AAAAeAAAyQAAFBQsLERERFxwcHCIiIigvLy8vNTU1Ozs7O0FBQUdNTU1NUlJSWFhYWF5eXmRpaWlpcG9vdnZ2dnx8fIKCgoKIiIiOlJSUlJqamp+fn5+mp6enrKyssbGxscbGxs3NzdLY2Nja4ODg4Obj4+no6Ojv7+/v9PT0+fn5+f///wAAAExhdmM1OC4xMwAAAAAAAAAAAAAAACQEKQAAAAAAAAAAAAAAAA//+xDEAAPAAAGkAAAAIAAANIAAAARMQU1FMy45OS41VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVf/7IMQFg8AAAaQAAAAgAAA0gAAABFVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVQ=='],
                        volume: 0.7
                    }),
                    click: new Howl({
                        src: ['data:audio/mp3;base64,SUQzAwAAAAAAJlRQRTEAAAAcAAAAU291bmRKYXkuY29tIFNvdW5kIEVmZmVjdHMA//uQxAADwAABpAAAACAAADSAAAAETEFNRTMuOTkuNVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVU='],
                        volume: 0.6
                    }),
                    bounce: new Howl({
                        src: ['data:audio/mp3;base64,SUQzAwAAAAAAJlRQRTEAAAAcAAAAU291bmRKYXkuY29tIFNvdW5kIEVmZmVjdHMA//uUxAADwAABpAAAACAAADSAAAAETEFNRTMuOTkuNVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVU='],
                        volume: 0.25, // Even lower volume for bounces
                        pool: 8 // Increase pool size
                    })
                };

                // --- Utility Functions ---
                function checkDevicePerformance() { /* ... (same as before) ... */
                     const isMobile = window.innerWidth <= 767;
                     const isLowPerformance = isMobile || (navigator.hardwareConcurrency && navigator.hardwareConcurrency <= 4) || (navigator.deviceMemory && navigator.deviceMemory < 4);
                    
                     if (isLowPerformance) {
                         if (!document.body.classList.contains('light-mode')) {
                            console.log("Light mode enabled.");
                            document.body.classList.add('light-mode');
                         }
                         isLightMode = true;
                     } else {
                         if (document.body.classList.contains('light-mode')) {
                             console.log("Light mode disabled.");
                            document.body.classList.remove('light-mode');
                         }
                         isLightMode = false;
                     }
                     return { isMobile, isLowPerformance };
                 }
                function getRandomPrize() { /* ... (same as before) ... */
                    let totalWeight = prizes.reduce((sum, prize) => sum + prize.weight, 0);
                    const random = Math.random() * totalWeight;
                    let weightSum = 0;
                    for (const prize of prizes) {
                        weightSum += prize.weight;
                        if (random < weightSum) {
                            return prize;
                        }
                    }
                    return prizes[prizes.length - 1]; // Fallback
                }
                function getFaceTranslateZ() { return window.innerWidth <= 767 ? 100 : 140; }
                function getMachineDimensions() { return window.innerWidth <= 767 ? { width: 240, height: 240 } : { width: 320, height: 320 }; }

                // --- Core Logic Functions ---
                function createOctagon() {
                    if (!octagonContainer) return; // Guard against null element
                    console.log("DEBUG: Creating octagon faces..."); // DEBUG
                    octagonContainer.innerHTML = '';
                    const numFaces = 8;
                    const angleIncrement = 360 / numFaces;
                    const translateZ = getFaceTranslateZ();
                    console.log(`DEBUG: Using translateZ = ${translateZ}`); // DEBUG

                    for (let i = 0; i < numFaces; i++) {
                        const face = document.createElement('div');
                        face.className = 'octagon-face';
                        face.style.transform = `rotateY(${i * angleIncrement}deg) translateZ(${translateZ}px)`;
                        // Adjust width/height based on screen size directly if CSS isn't reliable?
                         if (window.innerWidth <= 767) {
                             face.style.width = '100px';
                             face.style.height = '240px';
                             face.style.left = 'calc(50% - 50px)';
                         } else {
                            face.style.width = '140px';
                             face.style.height = '320px';
                             face.style.left = 'calc(50% - 70px)';
                         }
                        octagonContainer.appendChild(face);
                    }
                    console.log("DEBUG: Octagon faces created."); // DEBUG
                }

                function createBalls(count) {
                    console.log(`DEBUG: createBalls called with count: ${count}`); // DEBUG
                    if (!lotteryMachine) {
                        console.error("ERROR: lotteryMachine element not found in createBalls.");
                        return; // Stop if container is missing
                    }
                    balls = [];
                    const existingBalls = lotteryMachine.querySelectorAll('.ball');
                    console.log(`DEBUG: Removing ${existingBalls.length} existing balls.`); // DEBUG
                    existingBalls.forEach(ball => ball.remove());
                    
                    const { width: machineWidth, height: machineHeight } = getMachineDimensions();
                    const centerX = machineWidth / 2;
                    const centerY = machineHeight / 2; // Mid-height
                    const BALL_DIAM = getBallDiameter();
                    const BALL_RAD = getBallRadius();

                    console.log(`DEBUG: Machine Dims: ${machineWidth}x${machineHeight}, Center: ${centerX},${centerY}, Ball Radius: ${BALL_RAD}`); // DEBUG

                    for (let i = 0; i < count; i++) {
                        try {
                            const ball = document.createElement('div');
                            ball.className = 'ball';
                            ball.style.width = `${BALL_DIAM}px`; // Set size via JS too
                            ball.style.height = `${BALL_DIAM}px`;
                            ball.style.lineHeight = `${BALL_DIAM}px`;

                            const prize = getRandomPrize();
                            ball.textContent = prize.label;
                            ball.style.backgroundColor = prize.color;
                            ball.dataset.prize = prize.label;
                            
                            // --- Simplified Initial Position (Near Bottom Center) ---
                            const initialX = centerX + (Math.random() - 0.5) * machineWidth * 0.4; // Spread 40% width
                            const initialY = machineHeight * 0.7 + Math.random() * machineHeight * 0.2; // Lower 30%
                            const initialZ = (Math.random() - 0.5) * getFaceTranslateZ() * 0.3; // Small Z spread

                            // Calculate the CSS transform position (top-left corner)
                            const cssX = initialX - BALL_RAD;
                            const cssY = initialY - BALL_RAD;

                            console.log(`DEBUG: Ball ${i} - Initial State: [x:${initialX.toFixed(1)}, y:${initialY.toFixed(1)}, z:${initialZ.toFixed(1)}], CSS: [x:${cssX.toFixed(1)}, y:${cssY.toFixed(1)}]`); // DEBUG

                            // Apply initial CSS transform
                            ball.style.transform = `translate3d(${cssX}px, ${cssY}px, ${initialZ}px)`;
                            ball.style.opacity = '0.8'; // Ensure visible

                            lotteryMachine.appendChild(ball);
                            
                            // --- IMPORTANT: Store the CENTER coordinates in the physics state ---
                            balls.push({
                                element: ball,
                                x: initialX, // Store center X
                                y: initialY, // Store center Y
                                z: initialZ, // Store center Z
                                vx: (Math.random() - 0.5) * 0.5, // Tiny initial velocity
                                vy: (Math.random() - 0.5) * 0.5,
                                vz: (Math.random() - 0.5) * 0.5,
                                prize: prize,
                                radius: BALL_RAD // Store radius
                            });
                        } catch (ballError) {
                             console.error(`ERROR creating ball ${i}:`, ballError); // DEBUG
                         }
                    }
                    console.log(`DEBUG: Successfully created ${balls.length} balls.`); // DEBUG
                    // Force a reflow maybe?
                     void lotteryMachine.offsetWidth;
                }

                function updateBallPositions() {
                    if (!balls.length) return;

                    const maxRadius = getFaceTranslateZ() - getBallRadius();
                    const maxRadiusSquared = maxRadius * maxRadius;
                    const { width: machineWidth, height: machineHeight } = getMachineDimensions();
                    const centerX = machineWidth / 2;
                    // centerY calculation removed as Y=0 is top, Y=machineHeight is bottom
                    const spinEffectFactor = currentSpinSpeed * 0.005;
                    const BALL_RAD = getBallRadius(); // Get current radius

                    balls.forEach(ball => {
                         // Make sure radius is up-to-date (in case of resize)
                         ball.radius = BALL_RAD;

                        // 1. Apply Forces
                        ball.vy += GRAVITY;
                        const spinForceX = -spinEffectFactor * ball.z;
                        const spinForceZ = spinEffectFactor * (ball.x - centerX);
                        ball.vx += spinForceX;
                        ball.vz += spinForceZ;

                        // 2. Update Velocity
                        ball.vx *= FRICTION;
                        ball.vy *= FRICTION;
                        ball.vz *= FRICTION;

                        // 3. Update Position (Center coordinates)
                        ball.x += ball.vx;
                        ball.y += ball.vy;
                        ball.z += ball.vz;

                        // 4. Boundary Collisions
                        // Top/Bottom caps (Y-axis)
                        if (ball.y < ball.radius) {
                            ball.y = ball.radius;
                            ball.vy *= -BOUNDARY_ELASTICITY;
                            if (soundEnabled && Math.abs(ball.vy) > 0.2 && Math.random() < 0.05) sounds.bounce.play(); // Less frequent sounds
                        } else if (ball.y > machineHeight - ball.radius) {
                            ball.y = machineHeight - ball.radius;
                            ball.vy *= -BOUNDARY_ELASTICITY;
                            if (soundEnabled && Math.abs(ball.vy) > 0.2 && Math.random() < 0.05) sounds.bounce.play();
                        }

                        // Side walls (Radial distance in XZ plane)
                        const dx = ball.x - centerX;
                        const dz = ball.z;
                        const radialDistSq = dx * dx + dz * dz;

                        if (radialDistSq > maxRadiusSquared) {
                            const radialDist = Math.sqrt(radialDistSq);
                            const nx = dx / radialDist;
                            const nz = dz / radialDist;
                            const correction = radialDist - maxRadius;
                            ball.x -= nx * correction;
                            ball.z -= nz * correction;
                            const dotProduct = ball.vx * nx + ball.vz * nz;
                            ball.vx -= (1 + BOUNDARY_ELASTICITY) * dotProduct * nx;
                            ball.vz -= (1 + BOUNDARY_ELASTICITY) * dotProduct * nz;
                            if (soundEnabled && Math.sqrt(ball.vx*ball.vx + ball.vz*ball.vz) > 0.3 && Math.random() < 0.1) sounds.bounce.play();
                        }

                        // 5. Ball-Ball Collisions
                         for (let i = balls.indexOf(ball) + 1; i < balls.length; i++) {
                             const otherBall = balls[i];
                             const dx_bb = otherBall.x - ball.x;
                             const dy_bb = otherBall.y - ball.y;
                             const dz_bb = otherBall.z - ball.z;
                             const distSq = dx_bb * dx_bb + dy_bb * dy_bb + dz_bb * dz_bb;
                             const minDist = ball.radius + otherBall.radius;
                             const minDistSq = minDist * minDist;

                             if (distSq < minDistSq && distSq > 0.01) {
                                 const distance = Math.sqrt(distSq);
                                 const nx = dx_bb / distance;
                                 const ny = dy_bb / distance;
                                 const nz = dz_bb / distance;
                                 const overlap = minDist - distance;
                                 const separationFactor = 0.51;
                                 ball.x -= nx * overlap * separationFactor;
                                 ball.y -= ny * overlap * separationFactor;
                                 ball.z -= nz * overlap * separationFactor;
                                 otherBall.x += nx * overlap * separationFactor;
                                 otherBall.y += ny * overlap * separationFactor;
                                 otherBall.z += nz * overlap * separationFactor;
                                 const rvx = ball.vx - otherBall.vx;
                                 const rvy = ball.vy - otherBall.vy;
                                 const rvz = ball.vz - otherBall.vz;
                                 const velAlongNormal = rvx * nx + rvy * ny + rvz * nz;
                                 if (velAlongNormal > 0) continue;
                                 const impulse = -(1 + BALL_COLLISION_DAMPING) * velAlongNormal / 2;
                                 ball.vx += impulse * nx; ball.vy += impulse * ny; ball.vz += impulse * nz;
                                 otherBall.vx -= impulse * nx; otherBall.vy -= impulse * ny; otherBall.vz -= impulse * nz;
                                 if (soundEnabled && Math.abs(velAlongNormal) > 0.3 && Math.random() < 0.08) sounds.bounce.play();
                             }
                         }

                        // 6. Update Element Style
                        // Calculate CSS position (top-left corner) from center physics state
                        const cssX = ball.x - ball.radius;
                        const cssY = ball.y - ball.radius;
                        const scale = 1 + (ball.z / (getFaceTranslateZ() * 3)); // Adjust scaling based on Z
                        const opacity = 0.6 + 0.4 * ((ball.z + maxRadius) / (2 * maxRadius)); // Adjust opacity range

                        ball.element.style.transform = `translate3d(${cssX.toFixed(2)}px, ${cssY.toFixed(2)}px, ${ball.z.toFixed(2)}px) scale(${scale.toFixed(2)})`;
                        ball.element.style.zIndex = 500 + Math.floor(ball.y); // Base zIndex + y position
                        ball.element.style.opacity = Math.max(0.4, Math.min(1, opacity)).toFixed(2);

                         // DEBUG: Log position of one ball occasionally
                         // if (ball === balls[0] && Math.random() < 0.01) {
                         //     console.log(`Ball 0 - CSS: [${cssX.toFixed(1)}, ${cssY.toFixed(1)}, ${ball.z.toFixed(1)}]`);
                         // }
                    });
                }

                function rotateOctagon() {
                    if (!octagonContainer) return;
                    spinAngle += currentSpinSpeed;
                    // Normalize angle to prevent huge numbers? Optional.
                    // spinAngle = spinAngle % 360;
                    octagonContainer.style.transform = `rotateY(${spinAngle}deg)`;
                }

                function animate(timestamp) {
                    // DEBUG: Confirm loop runs
                    // console.log(`DEBUG: Animate loop - ts: ${timestamp.toFixed(0)}, spinning: ${isSpinning}, speed: ${currentSpinSpeed.toFixed(2)}, handle: ${handleAngle.toFixed(2)}`);

                    // Condition to stop the loop ONLY if nothing is happening
                    if (!isSpinning && Math.abs(currentSpinSpeed) < MIN_SPIN_SPEED && Math.abs(handleAngle) < 0.1 && !isDragging) {
                        // console.log("DEBUG: Stopping animation loop."); // DEBUG
                        animationFrameId = null;
                        return; // Stop the loop
                    }

                    rotateOctagon();
                    updateBallPositions();

                    // Deceleration logic
                    if (isSpinning && isDecelerating) {
                        currentSpinSpeed *= DECELERATION_FACTOR;
                        if (Math.abs(currentSpinSpeed) < MIN_SPIN_SPEED) {
                             console.log("DEBUG: Spin speed below minimum, stopping spin."); // DEBUG
                            stopSpinning(); // Trigger the stop sequence (sets isSpinning = false)
                        }
                    } else if (isSpinning && !isDecelerating) {
                        if (timestamp - spinStartTime >= SPIN_DURATION_BEFORE_DECEL) {
                            console.log("DEBUG: Spin duration reached, starting deceleration."); // DEBUG
                            isDecelerating = true;
                        }
                    }

                    // Handle spring-back animation
                    if (!isDragging && Math.abs(handleAngle) > 0.1) {
                        handleAngle *= 0.85;
                        handleVelocity *= 0.85;
                        handle.style.transform = `rotate(${handleAngle}deg)`;
                    } else if (!isDragging && handleAngle !== 0) {
                        handleAngle = 0;
                        handleVelocity = 0;
                        handle.style.transform = '';
                    }

                    // Continue the loop
                    animationFrameId = requestAnimationFrame(animate);
                }

                function startSpinning(initialSpeedBoost = 0) {
                    if (isSpinning) {
                        console.log("DEBUG: Already spinning, ignoring start request."); // DEBUG
                        return;
                    }
                    console.log(`DEBUG: startSpinning called with boost: ${initialSpeedBoost.toFixed(2)}`); // DEBUG

                    isSpinning = true;
                    isDecelerating = false;
                    spinStartTime = performance.now();
                    resultDisplay.textContent = '抽選中...';
                    resultDisplay.classList.remove('winning');

                    const speedMap = { slow: 2, medium: 4, fast: 6 };
                    let baseSpeed = speedMap[spinSpeedSelect.value] || 4;
                    
                    // Apply boost, ensuring direction is considered if boost is negative
                    currentSpinSpeed = baseSpeed * Math.sign(initialSpeedBoost || 1) + initialSpeedBoost; // Start in boost direction
                    // Ensure minimum speed magnitude
                    if (Math.abs(currentSpinSpeed) < (speedMap['slow'] / 2)) {
                       currentSpinSpeed = (speedMap['slow'] / 2) * Math.sign(currentSpinSpeed || 1);
                    }


                    console.log(`DEBUG: Spin started. Initial speed: ${currentSpinSpeed.toFixed(2)}`); // DEBUG

                    if (soundEnabled) sounds.spin.play();
                    spotlight.style.opacity = '0.7';

                    // Add impulse
                    balls.forEach(ball => {
                        ball.vx += (Math.random() - 0.5) * 4;
                        ball.vy += (Math.random() - 0.5) * 3 - 1.5; // More upward potential
                        ball.vz += (Math.random() - 0.5) * 4;
                    });

                    startButton.disabled = true;
                    resetButton.disabled = true;
                    ballCountInput.disabled = true;
                    spinSpeedSelect.disabled = true;

                    // --- IMPORTANT: Ensure animation loop starts ---
                    if (!animationFrameId) {
                        console.log("DEBUG: Starting animation loop from startSpinning."); // DEBUG
                        animationFrameId = requestAnimationFrame(animate);
                    }
                }

                function stopSpinning() {
                    console.log("DEBUG: stopSpinning called."); // DEBUG
                    isSpinning = false; // Set state first
                    currentSpinSpeed = 0;
                    isDecelerating = false;
                    if (octagonContainer) octagonContainer.style.transform = `rotateY(${spinAngle}deg)`; // Lock final angle

                    if (soundEnabled) sounds.spin.stop();
                    spotlight.style.opacity = '0';

                    if (!balls || balls.length === 0) {
                         console.warn("DEBUG: No balls to select winner from.");
                         resultDisplay.textContent = '請先重設';
                         // Re-enable controls immediately if no balls
                         startButton.disabled = false;
                         resetButton.disabled = false;
                         ballCountInput.disabled = false;
                         spinSpeedSelect.disabled = false;
                         return; // Exit early
                     }

                    // Winner Selection Logic (same as before)
                     let potentialWinners = balls.filter(ball => ball.y > (getMachineDimensions().height * 0.6));
                     if (potentialWinners.length === 0) potentialWinners = balls;
                     let winner = potentialWinners[0];
                     let bestScore = -Infinity;
                     potentialWinners.forEach(ball => {
                         const radialDistSq = (ball.x - getMachineDimensions().width / 2)**2 + (ball.z)**2;
                         const score = ball.y - Math.sqrt(radialDistSq) * 0.5;
                         if (score > bestScore) {
                             bestScore = score;
                             winner = ball;
                         }
                     });
                    if (!winner) winner = balls[Math.floor(Math.random() * balls.length)]; // Fallback


                    console.log("DEBUG: Winner selected:", winner?.prize?.label || 'None'); // DEBUG

                    if (winner) {
                        createParticleEffect(winner);
                         // Use a short delay before animation to ensure physics has settled? Maybe not needed.
                        gsap.to(winner.element, {
                            duration: 0.4,
                            scale: 1.8, // Use fixed scale, not dynamic here
                            boxShadow: `0 0 25px ${winner.prize.color}`,
                            ease: 'back.out(2)',
                            yoyo: true,
                            repeat: 3,
                            onComplete: () => {
                                showWinner(winner);
                                // Reset ball style after animation - use the scale from physics state
                                const finalScale = 1 + (winner.z / (getFaceTranslateZ() * 3));
                                gsap.to(winner.element, {
                                    duration: 0.3,
                                    scale: finalScale, // Return to physics scale
                                    boxShadow: 'inset 0 0 8px rgba(0, 0, 0, 0.2), 0 0 4px rgba(0, 0, 0, 0.3)'
                                });
                            }
                        });
                    } else {
                        resultDisplay.textContent = '抽選出錯';
                    }

                    // Re-enable controls (should happen regardless of winner found)
                    startButton.disabled = false;
                    resetButton.disabled = false;
                    ballCountInput.disabled = false;
                    spinSpeedSelect.disabled = false;

                    // Animation loop might stop itself if handle is also still
                }

                function showWinner(winner) { /* ... (same as before) ... */
                     if (!winner) return;
                     console.log("DEBUG: Showing winner display for", winner.prize.label); // DEBUG
                     if (soundEnabled) sounds.win.play();
                     winnerBall.style.backgroundColor = winner.prize.color;
                     winnerBall.textContent = winner.prize.label;
                     const messages = [ `恭喜！抽中了 ${winner.prize.label}！`, /* ... */ ];
                     winnerMessage.textContent = messages[Math.floor(Math.random() * messages.length)];
                     resultDisplay.textContent = `抽中: ${winner.prize.label}`;
                     resultDisplay.classList.add('winning');
                     winnerDisplay.classList.add('show');
                     gsap.fromTo(winnerDisplay.querySelector('.winner-content'), { scale: 0.5, opacity: 0 }, { scale: 1, opacity: 1, duration: 0.5, ease: 'back.out(1.7)' });
                 }
                function createParticleEffect(winner) { /* ... (same as before, ensure ballRect is valid) ... */
                    if (isLightMode || !winner || !winner.element) return;
                     try {
                         const particleCount = 50;
                         const colors = ['#FFD700', '#FFC107', '#FFA000', winner.prize.color, '#FFFFFF'];
                         const ballRect = winner.element.getBoundingClientRect();
                         if (!ballRect || ballRect.width === 0) {
                             console.warn("DEBUG: Cannot get valid rect for winner ball in createParticleEffect.");
                             return;
                         }
                         const startX = ballRect.left + ballRect.width / 2;
                         const startY = ballRect.top + ballRect.height / 2;

                         for (let i = 0; i < particleCount; i++) {
                             const particle = document.createElement('div');
                             particle.className = 'particle';
                             particle.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                             particle.style.left = `${startX}px`;
                             particle.style.top = `${startY}px`;
                             particlesContainer.appendChild(particle);
                             gsap.to(particle, {
                                 x: (Math.random() - 0.5) * 300, y: (Math.random() - 0.5) * 300,
                                 opacity: 1, scale: Math.random() * 1.5 + 0.5,
                                 duration: 0.6 + Math.random() * 0.4, ease: 'power3.out',
                                 onComplete: () => {
                                     gsap.to(particle, {
                                         opacity: 0, duration: 0.3 + Math.random() * 0.3, ease: 'power1.in',
                                         onComplete: () => particle.remove()
                                     });
                                 }
                             });
                         }
                    } catch (particleError) {
                        console.error("Error creating particles:", particleError);
                    }
                 }

                function resetLottery() {
                    console.log("DEBUG: resetLottery called."); // DEBUG
                    // Stop everything
                    isSpinning = false;
                    currentSpinSpeed = 0;
                    isDecelerating = false;
                    if (animationFrameId) cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                    if (soundEnabled) sounds.spin.stop();
                    spotlight.style.opacity = '0';
                    gsap.killTweensOf('.ball');
                    gsap.killTweensOf('.winner-content');
                    particlesContainer.innerHTML = ''; // Clear leftover particles

                    resultDisplay.textContent = '準備重新抽選...';
                    resultDisplay.classList.remove('winning');
                    winnerDisplay.classList.remove('show');

                    let count = parseInt(ballCountInput.value, 10);
                    count = Math.min(Math.max(count, 5), 30);
                    ballCountInput.value = count;

                    createBalls(count); // Recreate balls
                    spinAngle = 0;
                     if (octagonContainer) octagonContainer.style.transform = `rotateY(0deg)`; // Reset visual rotation

                    handleAngle = 0;
                    handleVelocity = 0;
                     if (handle) handle.style.transform = '';

                    startButton.disabled = false;
                    resetButton.disabled = false;
                    ballCountInput.disabled = false;
                    spinSpeedSelect.disabled = false;

                    setTimeout(() => {
                        if (!isSpinning) resultDisplay.textContent = '準備開始抽選...';
                    }, 500);
                    console.log("DEBUG: Lottery reset complete."); // DEBUG
                }

                function handleDrag() {
                     console.log("DEBUG: Setting up handle drag listeners."); // DEBUG
                    // Touch Events
                    handleContainer.addEventListener('touchstart', (e) => {
                        if (isSpinning) return;
                        isDragging = true;
                        dragStartY = e.touches[0].clientY;
                        lastDragY = dragStartY;
                        handleVelocity = 0;
                        handleContainer.style.cursor = 'grabbing';
                        if (!animationFrameId) { // Start loop on drag start if stopped
                             console.log("DEBUG: Starting animation loop from touchstart."); // DEBUG
                             animationFrameId = requestAnimationFrame(animate);
                        }
                    }, { passive: false });

                    document.addEventListener('touchmove', (e) => {
                        if (!isDragging) return;
                        e.preventDefault();
                        const currentY = e.touches[0].clientY;
                        const deltaY = currentY - lastDragY;
                        handleAngle += deltaY * 0.35; // Slightly more sensitive
                        handleAngle = Math.min(70, Math.max(-70, handleAngle)); // Wider angle range
                        handleVelocity = handleVelocity * 0.7 + deltaY * 0.3; // Faster velocity update
                        if (handle) handle.style.transform = `rotate(${handleAngle}deg)`;
                        lastDragY = currentY;
                    }, { passive: false });

                    document.addEventListener('touchend', (e) => {
                        if (!isDragging) return;
                        isDragging = false;
                        handleContainer.style.cursor = 'grab';
                        console.log(`DEBUG: Touchend - Velocity: ${handleVelocity.toFixed(2)}`); // DEBUG
                        if (Math.abs(handleVelocity) > HANDLE_DRAG_THRESHOLD && !isSpinning) {
                            if (soundEnabled) sounds.click.play();
                            // Boost direction based on velocity sign (pull down = positive velocity = clockwise?) Check this.
                            // Let's make pull down start counter-clockwise (-) spin
                            const speedBoost = -handleVelocity * 0.25; // Adjusted multiplier
                             console.log(`DEBUG: Touchend triggered spin with boost: ${speedBoost.toFixed(2)}`); // DEBUG
                            startSpinning(speedBoost);
                        }
                    });

                    // Mouse Events (similar logic)
                     handleContainer.addEventListener('mousedown', (e) => {
                         if (isSpinning) return;
                         e.preventDefault();
                         isDragging = true;
                         dragStartY = e.clientY;
                         lastDragY = dragStartY;
                         handleVelocity = 0;
                         handleContainer.style.cursor = 'grabbing';
                         if (!animationFrameId) {
                            console.log("DEBUG: Starting animation loop from mousedown."); // DEBUG
                            animationFrameId = requestAnimationFrame(animate);
                         }
                     });
                     document.addEventListener('mousemove', (e) => {
                         if (!isDragging) return;
                         const currentY = e.clientY;
                         const deltaY = currentY - lastDragY;
                         handleAngle += deltaY * 0.35;
                         handleAngle = Math.min(70, Math.max(-70, handleAngle));
                         handleVelocity = handleVelocity * 0.7 + deltaY * 0.3;
                         if (handle) handle.style.transform = `rotate(${handleAngle}deg)`;
                         lastDragY = currentY;
                     });
                     document.addEventListener('mouseup', (e) => {
                         if (!isDragging) return;
                         isDragging = false;
                         handleContainer.style.cursor = 'grab';
                          console.log(`DEBUG: Mouseup - Velocity: ${handleVelocity.toFixed(2)}`); // DEBUG
                         if (Math.abs(handleVelocity) > HANDLE_DRAG_THRESHOLD && !isSpinning) {
                             if (soundEnabled) sounds.click.play();
                              const speedBoost = -handleVelocity * 0.25;
                              console.log(`DEBUG: Mouseup triggered spin with boost: ${speedBoost.toFixed(2)}`); // DEBUG
                             startSpinning(speedBoost);
                         }
                     });
                }

                function toggleSound() { /* ... (same as before) ... */
                    soundEnabled = !soundEnabled;
                     Howler.mute(!soundEnabled);
                     console.log(`DEBUG: Sound ${soundEnabled ? 'Enabled' : 'Disabled'}`); // DEBUG
                     if (soundEnabled) {
                         soundStatus.textContent = "音效開啟";
                         soundToggle.querySelector('i').className = "fas fa-volume-up";
                     } else {
                         soundStatus.textContent = "音效關閉";
                         soundToggle.querySelector('i').className = "fas fa-volume-mute";
                         sounds.spin.stop(); // Ensure stop on mute
                     }
                 }

                // Initialize the application
                function init() {
                    console.log("DEBUG: init() called"); // DEBUG
                    const { isMobile } = checkDevicePerformance();
                    console.log(`DEBUG: isMobile: ${isMobile}, isLightMode: ${isLightMode}`); // DEBUG

                    createOctagon(); // Create faces first
                    
                    let initialBallCount = parseInt(ballCountInput.value, 10);
                    initialBallCount = Math.min(Math.max(initialBallCount, 5), 30);
                    ballCountInput.value = initialBallCount;
                    createBalls(initialBallCount); // Then create balls
                    
                    handleDrag();
                    
                    // Event Listeners
                    startButton.addEventListener('click', () => {
                         console.log("DEBUG: Start button clicked."); // DEBUG
                        if (!isSpinning) {
                            if (soundEnabled) sounds.click.play();
                            startSpinning(); // Start with default speed
                        }
                    });
                    resetButton.addEventListener('click', () => {
                        console.log("DEBUG: Reset button clicked."); // DEBUG
                        if (soundEnabled) sounds.click.play();
                        resetLottery();
                    });
                    soundToggle.addEventListener('click', toggleSound);
                    closeWinner.addEventListener('click', () => {
                        winnerDisplay.classList.remove('show');
                        if (soundEnabled) sounds.click.play();
                    });
                    ballCountInput.addEventListener('change', () => {
                        console.log("DEBUG: Ball count changed."); // DEBUG
                        let value = parseInt(ballCountInput.value, 10);
                        if (isNaN(value) || value < 5) value = 5;
                        if (value > 30) value = 30;
                        ballCountInput.value = value;
                        resetLottery();
                    });
                    spinSpeedSelect.addEventListener('change', () => {
                         console.log("DEBUG: Spin speed changed."); // DEBUG
                         if (soundEnabled) sounds.click.play();
                     });
                    window.addEventListener('resize', () => {
                         console.log("DEBUG: Window resized."); // DEBUG
                         checkDevicePerformance();
                         // Recreate/reset might be too disruptive on resize, maybe just update params?
                         // For now, let's keep the reset to ensure dimensions match
                         createOctagon();
                         resetLottery();
                     });
                    
                    resultDisplay.textContent = '準備開始抽選...';
                    console.log("DEBUG: Initialization complete."); // DEBUG
                }
                
                // --- Start Application ---
                init();
            }); // End DOMContentLoaded
        } catch (globalError) {
            console.error("########## GLOBAL SCRIPT ERROR ##########");
            console.error(globalError);
            alert("發生嚴重錯誤，請檢查控制台！");
        }
    </script>
</body>
</html>